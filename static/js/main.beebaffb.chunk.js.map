{"version":3,"sources":["jobIdToColor.js","GanttMachineSchedule.js","GanttXTicks.js","GattChart.js","worker.js","components/navbar.js","TwoDPlot.js","App.js","JSSP.js","serviceWorker.js","index.js"],"names":["jobIdToColour","jobid","str","hash","i","length","charCodeAt","colour","toString","substr","GanttMachineSchedule","props","Math","floor","random","a","this","schedule","start","end","_width","maxTime","_startpx","style","width","height","backgroundColor","position","left","transition","id","index","className","data-start","data-end","data-jobid","push","parentStyle","display","top","React","Component","GanttXTicks","ticks","maxTimePlus","tick","WATER_BOTTLING_WATER_MACHINES","GanttChart","console","log","allEnds","map","schArr","max","sch","idx","machineName","code","JSSPGanttChartSolution","getMakeSpan","arrForMachine","Infinity","forEach","item","JSSP1DEncoding","jobs1d","jssp1d","JSSP1dToGantt","jobInstance","ganttChart","numMachines","lastJobTime","Array","numJobs","fill","jobNumber","firstJob","jobs","splice","machine","time","firstAvailableTimeOnMachine","_lastJobTime","firstAvailableTime","generateRandom1D","base","nswap","randi","randj","randiVal","swap","j","array","temporaryValue","randomIndex","currentIndex","FishesYatesShuffle","sleep","miliseconds","currentTime","Date","getTime","onmessage","e","data","problem","algorithmRepetition","algorithmMaxTimeSecs","algorithmType","bestSolution1DEncoded","makeSpan","algoMaxEndTime","makeSpanHistory","randomizedInput","problemCopy","Object","assign","JSON","parse","stringify","ganttFromRandInput","newMakeSpan","returnData","type","iteration","postMessage","_runOptimizationAlgo","workerResult","substring","indexOf","lastIndexOf","blob","Blob","worker_script","URL","createObjectURL","NavBar","href","data-toggle","data-target","aria-controls","aria-expanded","aria-label","children","TwoDPlot","val","x","y","title","n","m","App","startJobShopWorker","workerInstance","Worker","WebWorkerScript","addEventListener","setState","iterations","state","minMakeSpanDetectedIteration","maxAlgorithmRepetition","handleChange","event","target","name","value","handleRestartJobShopWorkerButton","preventDefault","terminate","handleStopWorker","screenWidth","window","innerWidth","class","onChange","onClick","colSpan","placeholder","marginTop","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.beebaffb.chunk.js","sourcesContent":["// Modified from https://stackoverflow.com/questions/3426404/create-a-hexadecimal-colour-based-on-a-string-with-javascript\r\nfunction jobIdToColour(jobid) {\r\n    const str = `${jobid}color`\r\n    var hash = 0;\r\n    for (var i = 0; i < str.length; i++) {\r\n        hash = str.charCodeAt(i) + ((hash << 5) - hash);\r\n    }\r\n    var colour = '#';\r\n    for (var i = 0; i < 3; i++) {\r\n        var value = (hash >> (i * 8)) & 0xFF;\r\n        colour += ('00' + value.toString(16)).substr(-2);\r\n    }\r\n    return colour;\r\n}\r\n\r\nexport default jobIdToColour","import React from 'react';\r\nimport jobIdToColour from './jobIdToColor';\r\n\r\n/**\r\n * Idea here is to take an array\r\n */\r\nclass GanttMachineSchedule extends React.Component {\r\n    constructor(props){\r\n        super(props)\r\n    }\r\n    randColor(){\r\n        return Math.floor(Math.random() * 180) //use 180 instead of 255 to avoid colors too light\r\n    }\r\n\r\n    render(){\r\n        let a = [] \r\n        for(let i = 0; i< this.props.schedule.length; i++){\r\n            if(i%3 === 0){\r\n                const jobid = this.props.schedule[i];\r\n                const start = this.props.schedule[i + 1];\r\n                const end = this.props.schedule[i + 2];\r\n                const _width = 100* (end - start)/this.props.maxTime\r\n                const _startpx = 100* start / this.props.maxTime\r\n                const style = {\r\n                    width:`${_width}%`,\r\n                    height: '20px',\r\n                    // border:'black',\r\n                    backgroundColor:`${jobIdToColour(jobid)}`,\r\n                    position:'absolute',\r\n                    left:`${_startpx}%`,\r\n                    transition: 'all 1s linear'\r\n                }\r\n\r\n                const width = <div id={`key-${this.props.index}-${jobid}`} className={`job-${jobid}`}  style={style} data-start={start} data-end={end} data-jobid={jobid}>Job-{jobid}</div>\r\n                a.push(width)\r\n            }\r\n            continue\r\n        }\r\n        const parentStyle = {\r\n            position:'relative',\r\n            display:'flex',\r\n            top:`${this.props.index * 25}px`\r\n        }\r\n        return (\r\n            <div style={parentStyle}>\r\n                {a}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GanttMachineSchedule","import React from 'react';\r\n\r\nclass GanttXTicks extends React.Component {\r\n    render(){\r\n        const parentStyle = {\r\n            position:'relative',\r\n            top:`${(this.props.index) * 25}px`,\r\n        }\r\n        const ticks = []\r\n        const maxTimePlus = ((this.props.maxTime/10)+1 )*10\r\n        for(let i = 0; i<maxTimePlus; i++){\r\n            const _startpx = 100* i / this.props.maxTime\r\n            const style = {\r\n                left:`${_startpx}%`,\r\n                transition: 'all 1s linear',\r\n                position:'absolute'\r\n            }\r\n            if(i%10 === 0){\r\n                const tick = <span style={style}>\r\n                    <div>|</div>\r\n                    <div>{i}</div>\r\n                    </span>\r\n                ticks.push(tick);\r\n            }\r\n        }\r\n        return (\r\n            <div style={parentStyle}>\r\n                {ticks}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GanttXTicks","import React from 'react';\r\nimport GanttMachineSchedule from './GanttMachineSchedule';\r\nimport GanttXTicks from './GanttXTicks';\r\n\r\nconst WATER_BOTTLING_WATER_MACHINES = [\r\n    \"Bottle Expansion Mold\",\r\n    \"Water Cleaning/ Purifying\",\r\n    \"Water Filling\",\r\n    \"Bottle Capping\",\r\n    \"Bottle Labeling\"\r\n]\r\nclass GanttChart extends React.Component {\r\n    render(){\r\n        console.log(this.props)\r\n        const allEnds = this.props.schedule.map(schArr => schArr[schArr.length-1])\r\n        console.log(allEnds)\r\n        const maxTime = Math.max(...allEnds)\r\n        return (\r\n        \r\n            <div className=\"ganttChartWithY\">\r\n                <div className=\"ganttChartYAxis\">\r\n                    {this.props.schedule.map( (sch,idx)=>{\r\n                        const machineName = WATER_BOTTLING_WATER_MACHINES[idx]\r\n                        return <span className=\"yAxisTick\">{`${machineName} Machine`}</span>\r\n                    })}\r\n\r\n                </div>\r\n                <div className=\"ganttChartData\">\r\n                    {this.props.schedule.map( (sch,idx) => \r\n                        <GanttMachineSchedule schedule={sch} maxTime={maxTime} index={idx}/>)}\r\n                    <GanttXTicks index={this.props.schedule.length} maxTime={maxTime} />\r\n                </div>\r\n            </div>\r\n            \r\n        )\r\n    }\r\n}\r\nexport default GanttChart","import GanttChart from \"./GattChart\";\r\n\r\nconst workercode = () => {\r\n    \r\n    const JSSPProblemInstance = (n,m) => {\r\n        this.numJobs = n;\r\n        this.numMachines = m\r\n        this.jobs = []; // list of lists.\r\n    }\r\n    \r\n    const JSSPGanttChartSolution = function(schedule){\r\n        /**\r\n         * Gantt Chart looks like this:\r\n         * [\r\n         *  [jobId,StartTime,EndTime,jobId,StartTime,EndTime,...]   -> for Machine with Index 0 \r\n         *  [jobId,StartTime,EndTime,...]   -> for Machine with Index 1\r\n         * ]\r\n         * It is useful to have GanttChart in this format because it lets us \r\n         * read the ganttChart in text format without any special help.\r\n         */\r\n        this.schedule = schedule\r\n        this.getMakeSpan = ()=>{\r\n            /**\r\n             * Calculates MakeSpan of an instance of a JSSP Gantt Chart Solution\r\n             * In our definition of ganttChart, we choose last integer of each array if array>0. \r\n             * and return max of them\r\n             */\r\n            const allEnds = this.schedule.map(arrForMachine => {\r\n                if(!arrForMachine.length || arrForMachine.length === 0){\r\n                    return 0\r\n                }\r\n                return arrForMachine[arrForMachine.length -1 ]\r\n            });\r\n            let max = -Infinity;\r\n            allEnds.forEach(item => {\r\n                if(item > max){\r\n                    max = item\r\n                }\r\n            })\r\n            return max\r\n            //return Math.max(...allEnds)\r\n        }\r\n    }\r\n    \r\n    \r\n    function JSSP1DEncoding(jobs1d){\r\n        /**\r\n         * Most JSSP problems have way too many ways to run, we need to generate options randomly\r\n         * Since randomly generating options is harder in  2d array while meeting all the constraints\r\n         * we will use a 1D Encoding. We also have functions to convert this into Gantt Chart. \r\n         * \r\n         * This can be represented as a singe array as well.\r\n         */\r\n        this.jssp1d = jobs1d\r\n        // Example jssp1d = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n    \r\n        this.JSSP1dToGantt = (jobInstance) => {\r\n            /**\r\n             * Given a 1D solution, convert it into Gantt Chart Solution. \r\n             */\r\n            //const test1D = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n            // const test1D =[0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]\r\n            // const m = 5 // Number of Machines: 0,1,2,3,4,5\r\n            // const n = 4 // Number of Jobs. 0,1,2,3 -> as denoted in the 1d strucutre. \r\n            const ganttChart = []\r\n            for(let i = 0; i<jobInstance.numMachines; i++){\r\n                ganttChart.push([])\r\n            }\r\n            //console.log(ganttChart)\r\n        \r\n            // Next we fill the ganttChart with data based on test1D\r\n            // We need access to the job instance so that we can look at\r\n            \r\n            // Keep Track of last time for each job.\r\n            const lastJobTime = new Array(jobInstance.numJobs).fill(0)\r\n            // console.log(\"Last Job Time\", lastJobTime)\r\n        \r\n            //console.log(jobInstance)\r\n            this.jssp1d.forEach(jobNumber => {\r\n                // job jobNumber is assigned to its respective first. \r\n                const jobDef = jobInstance.jobs[jobNumber]\r\n                // console.log(\"job def is\", jobDef);\r\n                // Get the first one out.\r\n                const firstJob = jobDef.splice(0,2);\r\n                // console.log(`Current Job for Job Number ${jobNumber}  :` ,firstJob)\r\n                const machine = firstJob[0];\r\n                const time = firstJob[1]\r\n        \r\n                // Now fill Gantt Chart\r\n                const firstAvailableTimeOnMachine = ganttChart[machine].length === 0 ? 0 : ganttChart[machine][ganttChart[machine].length -1]\r\n                // What is the last time of dependent job? We can find that out dependent jobs by looking at job instance from before...\r\n                const _lastJobTime = lastJobTime[jobNumber]\r\n                const firstAvailableTime = Math.max(_lastJobTime,firstAvailableTimeOnMachine)\r\n                lastJobTime[jobNumber] = firstAvailableTime+time\r\n                \r\n                const ganttSchedule = [jobNumber,firstAvailableTime+1,firstAvailableTime+time ]\r\n                const newList = []\r\n                //ganttChart[machine].forEach(item => newList.push(item))\r\n                ganttSchedule.forEach(item => ganttChart[machine].push(item))\r\n                //ganttChart[machine] = newList // [...ganttChart[machine], ...ganttSchedule]\r\n                \r\n            })\r\n        \r\n            //console.log(ganttChart)\r\n    \r\n            return new JSSPGanttChartSolution(ganttChart)\r\n        }\r\n    }\r\n    \r\n    function FishesYatesShuffle(array) {\r\n        var currentIndex = array.length, temporaryValue, randomIndex;\r\n      \r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n      \r\n          // Pick a remaining element...\r\n          randomIndex = Math.floor(Math.random() * currentIndex);\r\n          currentIndex -= 1;\r\n      \r\n          // And swap it with the current element.\r\n          temporaryValue = array[currentIndex];\r\n          array[currentIndex] = array[randomIndex];\r\n          array[randomIndex] = temporaryValue;\r\n        }\r\n      \r\n        return array;\r\n    }\r\n    \r\n    function generateRandom1D(numMachines, numJobs, base, nswap) {\r\n        if (base){\r\n            // if base is passed in - just do a swap once. nswap not used at the moment.\r\n            function swap(){\r\n                const randi = Math.floor(Math.random() * base.length )\r\n                let randj = Math.floor(Math.random() * base.length )\r\n                while(base[randi] === base[randj]){ // no point in swapping the same number.\r\n                    randj = Math.floor(Math.random() * base.length )\r\n                }\r\n                const randiVal = base[randi]\r\n                base[randi] = base[randj]\r\n                base[randj] = randiVal\r\n            }\r\n            swap()\r\n            return new JSSP1DEncoding(base) // spread to avoid side effects.\r\n        }\r\n        // We want each jobs repetead numMachines of times. \r\n        let jobs = []\r\n        for(let i = 0;i < numJobs; i++){\r\n            for(let j = 0; j < numMachines; j++){\r\n                jobs.push(i)\r\n            }\r\n            //const values = new Array(numMachines).fill(i) // Fill with Job Number \r\n            //jobs.concat(values)\r\n            //jobs = [...jobs, ...values]\r\n        }\r\n        console.log(\"done creating jobs\")\r\n        console.log(jobs)\r\n        const jssp1d = new JSSP1DEncoding(FishesYatesShuffle(jobs))\r\n        console.log(jssp1d)\r\n        return jssp1d\r\n        console.log(jobs)\r\n    };\r\n    function sleep(miliseconds) { \r\n        /**\r\n         * Evil sleep function used for demoing simulation.\r\n         * Since the example problem I am using solves really fast, I am adding sleep in the thread.\r\n         * TODO >> Actually use setTimeOut to accomplish the same thing so thread isn't running while waiting.\r\n         */\r\n        var currentTime = new Date().getTime();\r\n     \r\n        while (currentTime + miliseconds >= new Date().getTime()) {\r\n        }\r\n     }\r\n     \r\n    function _runOptimizationAlgo(problem, algorithmRepetition, algorithmMaxTimeSecs, algorithmType) {\r\n        console.log(\"inside run optimization , this is \");\r\n        console.log(this);\r\n        console.log(generateRandom1D && \"generate Random 1d is available\")\r\n        let makeSpan = Infinity;\r\n        const algoStartTime = (new Date).getTime();\r\n        const algoMaxEndTime = algoStartTime + (algorithmMaxTimeSecs * 1000)\r\n        const makeSpanHistory = []\r\n        let bestSolution1DEncoded;  // Store the best solution encoded in 1d so far.\r\n        for(let i = 0; i < algorithmRepetition; i ++){\r\n            if( (i%5===0) && (new Date).getTime() > algoMaxEndTime) {\r\n                console.log(\"Ran for too long already\")\r\n                break;\r\n            }\r\n\r\n            if( (i%100==0) && (new Date).getTime() > algoMaxEndTime){ //Run time check every 100th run.\r\n                console.log(\"Ending because of time limit\")\r\n                console.log(\"Ran times : \" , i)\r\n                break;\r\n            }\r\n            const randomizedInput = generateRandom1D(problem.numMachines, problem.numJobs, algorithmType === \"hillClimbing\" ? bestSolution1DEncoded && bestSolution1DEncoded.jssp1d : null)\r\n            const problemCopy = Object.assign({}, problem)\r\n            problemCopy.jobs = JSON.parse(JSON.stringify(problem.jobs))\r\n\r\n            const ganttFromRandInput = randomizedInput.JSSP1dToGantt(problemCopy)\r\n            const newMakeSpan = ganttFromRandInput.getMakeSpan();\r\n            console.log(\"adding to newmakespan from worer\")\r\n            makeSpanHistory.push(newMakeSpan)\r\n            if(i%1  === 0){\r\n                const returnData = {\r\n                    type:'iterationCount',\r\n                    iteration:i+1,\r\n                    newMakeSpan:makeSpanHistory\r\n                }\r\n                this.postMessage(returnData);\r\n                sleep(1*200) // Give UI thread enough time to renderthis.\r\n                makeSpanHistory.length = 0\r\n            }\r\n            \r\n            // console.log(ganttFromRandInput.schedule[0])\r\n            if(newMakeSpan < makeSpan){\r\n                makeSpan = newMakeSpan\r\n                // gantt = ganttFromRandInput\r\n                bestSolution1DEncoded = randomizedInput\r\n                console.log(\"Found Better\", ganttFromRandInput)\r\n                console.log(\"New Make Span at index \", i, newMakeSpan)\r\n                this.postMessage(\"Got New MakeSpan\")\r\n                const returnData = {\r\n                    'type':'newSchedule',\r\n                    'schedule':ganttFromRandInput.schedule,\r\n                    'makeSpan':makeSpan,\r\n                    \"minMakeSpanDetectedIteration\": i\r\n                }\r\n                this.postMessage(returnData);\r\n                sleep(1*1000)\r\n                // this.setState({\r\n                //   schedule:ganttFromRandInput.schedule,\r\n                //   makeSpan:makeSpan\r\n                // })\r\n            }\r\n        }\r\n    }\r\n\r\n    onmessage = function(e) {\r\n        const that = this;\r\n        console.log(\"this inside onmessage\")\r\n        console.log(this)\r\n        console.log('Message received from main script');\r\n        console.log(\"message\", e);\r\n        const { problem, algorithmRepetition, algorithmMaxTimeSecs, algorithmType} = e.data; \r\n        console.log(problem, algorithmMaxTimeSecs);\r\n        _runOptimizationAlgo(problem, algorithmRepetition, algorithmMaxTimeSecs, algorithmType, that)\r\n        var workerResult = 'Received from main: ' + (e.data);\r\n        console.log('Posting message back to main script');\r\n        this.postMessage(workerResult);\r\n    }\r\n};\r\n\r\nlet code = workercode.toString();\r\ncode = code.substring(code.indexOf(\"{\")+1, code.lastIndexOf(\"}\"));\r\n\r\nconst blob = new Blob([code], {type: \"application/javascript\"});\r\nconst worker_script = URL.createObjectURL(blob);\r\n\r\nexport default worker_script;\r\n","import React from 'react'\r\nfunction NavBar(props){\r\n    return (\r\n        <nav className=\"navbar navbar-expand-lg navbar-dark\" style={{backgroundColor:'#34495e'}}>\r\n            <a className=\"navbar-brand\" href=\"/\">Water Bottle Plant Makespan Optimization</a>\r\n            <button className=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\r\n                <span className=\"navbar-toggler-icon\"></span>\r\n            </button>\r\n\r\n            <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\r\n                <ul className=\"navbar-nav mr-auto\">\r\n                    {props.children}\r\n                </ul>\r\n            </div>\r\n        </nav>\r\n    )\r\n}\r\n\r\nfunction SubNavBar(props){\r\n    return (\r\n        <nav className=\"navbar navbar-expand-lg navbar-inverse\" >\r\n            <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\r\n                <ul className=\"navbar-nav mr-auto\">\r\n                    <li className=\"nav-item active\">\r\n                        <a className=\"nav-link\" href=\"/\">Random Algorithm <span className=\"sr-only\">(current)</span></a>\r\n                    </li>\r\n                    <li className=\"nav-item\">\r\n                        <a disabled className=\"nav-link\" href=\"/\">Neighbourhood search algorithm (Coming Soon)</a>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </nav>\r\n    )\r\n}\r\n\r\nexport { NavBar, SubNavBar }","import React, { Component } from 'react';\r\nimport './App.css';\r\nimport '../node_modules/react-vis/dist/style.css';\r\nimport {XYPlot, LineSeries, HorizontalGridLines, VerticalGridLines, XAxis, YAxis} from 'react-vis';\r\n\r\nclass TwoDPlot extends Component {\r\n  render() {\r\n    console.log(this.props);\r\n    // Get props.data = [123,345,345,999 ...] from parent. \r\n    const data = this.props.data.map((val,idx)=>{\r\n      return {\r\n        x: idx,\r\n        y: val\r\n      }\r\n    })\r\n\r\n    return (\r\n      <div className=\"twodplot\">\r\n        <div>\r\n          <XYPlot height={this.props.height || 300} width={this.props.width || 300}>\r\n            <LineSeries data={data} />\r\n            <XAxis title=\"Number of Iterations\" />\r\n            <YAxis title=\"MakeSpan\" />\r\n            <VerticalGridLines />\r\n            <HorizontalGridLines />\r\n          </XYPlot>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default TwoDPlot","import React from 'react';\r\nimport './App.css';\r\nimport GanttChart from './GattChart';\r\nimport jobIdToColour from './jobIdToColor';\r\nimport WebWorkerScript from './worker';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport { JSSPProblemInstance } from './JSSP';\r\nimport { NavBar } from './components/navbar';\r\nimport TwoDPlot from './TwoDPlot';\r\n\r\n// Create a new instance of JSSPProblemInstance and assign jobs for water bottle plant.\r\nconst problem = new JSSPProblemInstance(4,5) // Instantiate with no data. \r\n/**\r\n * Water Bottoling Plant that does 4 different types of water bottles. \r\n * Job 0 - Spring Water 16oz\r\n * Job 1 - Distilled Water 16 oz\r\n * Job 2 - Distilled Water 32 oz\r\n * Job 4 - Bottoled Water 32 oz\r\n * \r\n * We have 5 machines for different operations\r\n * Machine 0 - Bottle Expansion Molding\r\n * Machine 1 - Water Cleaning or purifying Machine \r\n * Machine 2 - Pouring water / Filling Process \r\n * Machine 3 - Capping\r\n * Machine 4 - Labelling\r\n * \r\n * Jobs must be run in the following order\r\n */\r\nproblem.jobs = [\r\n  [0, 10, 1, 10, 2, 10, 3, 10, 4, 8],\r\n  [0, 50, 1, 15, 2, 10, 3, 10, 4, 16],\r\n  [0, 30, 1, 12, 2, 20, 3, 10, 4, 16],\r\n  [0, 15, 1, 30, 2, 20, 3, 10, 4, 10],\r\n]\r\n\r\n// Example Problem Statement\r\n// problem.jobs = [ \r\n//   [ 0, 10, 1, 20, 2, 20, 3, 40, 4, 10 ],\r\n//   [ 1, 20, 0, 10, 3, 30, 2, 50, 4, 30 ],\r\n//   [ 2, 30, 1, 20, 4, 12, 3, 40, 0, 10 ],\r\n//   [ 4, 50, 3, 30, 2, 15, 0, 20, 1, 15 ] ]\r\n\r\n// Complicated Problem Statement -> Uncomment below..\r\n// problem.numJobs = 10\r\n// problem.numMachines = 10\r\n// problem.jobs = [\r\n// [ 4, 88, 8, 68, 6, 94, 5, 99, 1, 67, 2, 89, 9, 77, 7, 99, 0, 86, 3, 92 ],\r\n// [ 5, 72, 3, 50, 6, 69, 4, 75, 2, 94, 8, 66, 0, 92, 1, 82, 7, 94, 9, 63 ],\r\n// [ 9, 83, 8, 61, 0, 83, 1, 65, 6, 64, 5, 85, 7, 78, 4, 85, 2, 55, 3, 77 ],\r\n// [ 7, 94, 2, 68, 1, 61, 4, 99, 3, 54, 6, 75, 5, 66, 0, 76, 9, 63, 8, 67 ],\r\n// [ 3, 69, 4, 88, 9, 82, 8, 95, 0, 99, 2, 67, 6, 95, 5, 68, 7, 67, 1, 86 ],\r\n// [ 1, 99, 4, 81, 5, 64, 6, 66, 8, 80, 2, 80, 7, 69, 9, 62, 3, 79, 0, 88 ],\r\n// [ 7, 50, 1, 86, 4, 97, 3, 96, 0, 95, 8, 97, 2, 66, 5, 99, 6, 52, 9, 71 ],\r\n// [ 4, 98, 6, 73, 3, 82, 2, 51, 1, 71, 5, 94, 7, 85, 0, 62, 8, 95, 9, 79 ],\r\n// [ 0, 94, 6, 71, 3, 81, 7, 85, 1, 66, 2, 90, 4, 76, 5, 58, 8, 93, 9, 97 ],\r\n// [ 3, 50, 0, 59, 1, 82, 8, 67, 7, 56, 9, 96, 6, 58, 4, 81, 5, 59, 2, 96 ]\r\n// ]\r\n\r\nclass App extends React.Component {\r\n  constructor(props){\r\n    super(props)\r\n    this.state = {\r\n      schedule:[[],[]],\r\n      makeSpan:Infinity,\r\n      minMakeSpanDetectedIteration:0,\r\n      iterations:0,\r\n      workerInstance : new Worker(WebWorkerScript),\r\n      makeSpanHistory:[],\r\n      maxAlgorithmRepetition:50,\r\n      algorithmMaxTimeSecs:30,\r\n      algorithmType: 'hillClimbing' // random || hillClimbing\r\n    }\r\n  }\r\n  startJobShopWorker = () => {\r\n    const workerInstance = new Worker(WebWorkerScript);\r\n    \r\n    workerInstance.addEventListener(\"message\", e => {\r\n      // We can have 2 different data types or a generic message stored in e.data\r\n      // {\"type\":\"iterationCount\",\"value\":200}\r\n      // {\"type\":\"newSchedule\",\"value\":[[],...]}\r\n      if(e.data && e.data.type === \"iterationCount\"){\r\n        this.setState({\r\n          iterations:e.data.iteration,\r\n          makeSpanHistory:[...this.state.makeSpanHistory,...e.data.newMakeSpan]\r\n        })\r\n      }\r\n      else if(e.data && e.data.type === \"newSchedule\"){\r\n        this.setState({\r\n          schedule : e.data.schedule, makeSpan:e.data.makeSpan,\r\n          minMakeSpanDetectedIteration: e.data.minMakeSpanDetectedIteration\r\n        });\r\n      } else {\r\n        console.log(\"generic Message \", e.data);\r\n      } \r\n    }, false);\r\n    \r\n    workerInstance.postMessage({\r\n      algorithmRepetition:this.state.maxAlgorithmRepetition,\r\n      problem:problem,\r\n      algorithmMaxTimeSecs:this.state.algorithmMaxTimeSecs,\r\n      algorithmType: this.state.algorithmType\r\n    })\r\n\r\n    this.setState({\r\n      workerInstance: workerInstance,\r\n    })\r\n  }\r\n\r\n  componentDidMount(){\r\n    this.startJobShopWorker()\r\n  }\r\n  handleChange = (event)=>{\r\n    this.setState({[event.target.name]: event.target.value});\r\n  }\r\n\r\n  handleRestartJobShopWorkerButton = (e)=>{\r\n    e.preventDefault();\r\n    this.state.workerInstance.terminate();\r\n    this.setState({\r\n      schedule:[[],[]],\r\n      makeSpan:Infinity,\r\n      minMakeSpanDetectedIteration:0,\r\n      iterations:0,\r\n      makeSpanHistory:[],\r\n    },this.startJobShopWorker() )\r\n    \r\n  }\r\n  handleStopWorker = (e) => {\r\n    this.state.workerInstance.terminate();\r\n  }\r\n  render(){\r\n    const screenWidth = (window.innerWidth - 60)\r\n    return (\r\n      <div className=\"App\">\r\n        <NavBar>\r\n          <li class=\"nav-item\">\r\n            <select className=\"form-control ml-2\" name=\"algorithmType\" onChange={this.handleChange} value={this.state.algorithmType}>\r\n              <option value=\"random\">Random Search</option>\r\n              <option value=\"hillClimbing\">Hill Climbing Search</option>\r\n            </select>\r\n          </li> \r\n\r\n          <li class=\"nav-item ml-2\">\r\n            <button className=\"btn btn-outline-danger ml-2\" onClick={this.handleStopWorker}> Stop </button>\r\n          </li>\r\n          \r\n          <li class=\"nav-item ml-2\">\r\n            <button className=\"btn btn-outline-success\" onClick={this.handleRestartJobShopWorkerButton}>  Restart with new settings </button>\r\n          </li>\r\n        </NavBar>\r\n\r\n        <div className=\"container\">\r\n          <div className=\"row\">\r\n            <div className=\"col\">\r\n              <table className=\" table table-sm mt-2\">\r\n                <thead>\r\n                  <tr>\r\n                    <th colSpan={2}>Simulation Parameters </th>\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  <tr>\r\n                    <td>Number of Simulations</td>\r\n                    <td>{this.state.iterations} </td>\r\n                  </tr>\r\n                  <tr>\r\n                    <td>Minimal Makespan Detected</td>\r\n                    <td>{this.state.makeSpan}</td>\r\n                  </tr>\r\n                  <tr>\r\n                    <td>Min detected after iteration</td>\r\n                    <td>{this.state.minMakeSpanDetectedIteration}</td>\r\n                  </tr>\r\n                </tbody>\r\n              </table>\r\n\r\n            </div>\r\n            <div className=\"col\">\r\n              <table className=\"table table-sm mt-2\">\r\n                <thead>\r\n                  <tr>\r\n                    <th colSpan={2}>Termination Criteria</th>\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  <tr>\r\n                    <td>Number of Simuations</td>\r\n                    <td>\r\n                      <input type=\"number\" style={{width:'4em'}} name=\"maxAlgorithmRepetition\" onChange={this.handleChange} value={this.state.maxAlgorithmRepetition}/>\r\n                    </td>\r\n                  </tr>\r\n                  <tr>\r\n                    <td>Maximum Time in seconds</td>\r\n                    <td>\r\n                      <input type=\"number\" style={{width:'4em'}} name=\"algorithmMaxTimeSecs\" onChange={this.handleChange} value={this.state.algorithmMaxTimeSecs} class=\"form-controll\" placeholder=\"Max number of iterations\"/>\r\n                    </td>\r\n                  </tr>\r\n                </tbody>\r\n              </table>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div style={{marginTop:'10px'}}>\r\n          <h6>Plot of makespan during each different simulation</h6>\r\n          <TwoDPlot data={this.state.makeSpanHistory} width={screenWidth} />\r\n        </div>\r\n        <hr></hr>\r\n        <h6>Schedule with the least makespan</h6>\r\n        <GanttChart schedule={this.state.schedule}/>\r\n        \r\n\r\n        <div className=\"explanation\">\r\n\r\n        <p>\r\n        The Chart above shows the order in which each operation in a water bottling plant must run on each machine to complete all bottling activities in the most efficient manner. \r\n        Watch the chart change as the algorithm finds more and more efficient way to run the factory over time. Simulation is slowed down for demonstration purpose.\r\n        Run the simulations with different settings below: \r\n        </p>\r\n                \r\n        <hr></hr>\r\n        <h3>Explanation</h3>\r\n\r\n          In this demo, we are trying to optimize how to run a water bottling plant. We have 5 machines for different operations, and various different types of products we need to produce.\r\n\r\n\r\n        <ol>\r\n          <li>Machine 0 - Bottle Expansion Molding</li>\r\n          <li>Machine 1 - Water Cleaning or purifying Machine </li>\r\n          <li>Machine 2 - Pouring water / Filling Process </li>\r\n          <li>Machine 3 - Capping</li>\r\n          <li>Machine 4 - Labelling</li>\r\n        </ol>\r\n\r\n        This factory produces 4 different types of water bottles, and each water bottling operation must be run in the following order:\r\n        <ol>\r\n          <li><span style={{backgroundColor:`${jobIdToColour(0)}`}}>Job 0 - Spring Water 16oz </span>\r\n              <ol>\r\n                <li>Bottle Expansion - 10 seconds</li>\r\n                <li>Water Purifying - 30 seconds</li>\r\n                <li>Water Filling - 10 seconds</li>\r\n                <li>Bottle Capping - 10 seconds</li>\r\n                <li>Bottle Labeling - 8 seconds</li>\r\n              </ol>\r\n          </li>\r\n          <li><span style={{backgroundColor:`${jobIdToColour(1)}`}}>Job 1 - Distilled Water 16 oz</span>\r\n              <ol>\r\n                <li>Bottle Expansion - 50 seconds</li>\r\n                <li>Water Purifying - 60 seconds</li>\r\n                <li>Water Filling - 10 seconds</li>\r\n                <li>Bottle Capping - 10 seconds</li>\r\n                <li>Bottle Labeling - 16 seconds</li>\r\n              </ol>\r\n          </li>\r\n          <li><span style={{backgroundColor:`${jobIdToColour(2)}`}}>Job 2 - Distilled Water 32 oz</span>\r\n              <ol>\r\n                <li>Bottle Expansion - 30 seconds</li>\r\n                <li>Water Purifying - 90 seconds</li>\r\n                <li>Water Filling - 20 seconds</li>\r\n                <li>Bottle Capping - 10 seconds</li>\r\n                <li>Bottle Labeling - 16 seconds</li>\r\n              </ol>\r\n          </li>\r\n          <li><span style={{backgroundColor:`${jobIdToColour(3)}`}}>Job 3 - Bottoled Water 32 oz</span>\r\n              <ol>\r\n                <li>Bottle Expansion - 15 seconds</li>\r\n                <li>Water Purifying - 90 seconds</li>\r\n                <li>Water Filling - 20 seconds</li>\r\n                <li>Bottle Capping - 10 seconds</li>\r\n                <li>Bottle Labeling - 10 seconds</li>\r\n              </ol>\r\n          </li>\r\n        </ol>\r\n\r\n        Algorithm that runs in the background finds the most optimal way of running all the jobs in the given order. \r\n\r\n        The Chart shows the order in which each job must run on each machine to complete all bottling activities in the most efficient manner. \r\n        Watch the chart change as the algorithm finds more and more efficient way to run the factory. \r\n\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","function JSSPProblemInstance(n,m){\r\n    this.numJobs = n;\r\n    this.numMachines = m\r\n    this.jobs = []; // list of lists.\r\n}\r\n\r\nfunction JSSPGanttChartSolution(schedule){\r\n    /**\r\n     * Gantt Chart looks like this:\r\n     * [\r\n     *  [jobId,StartTime,EndTime,jobId,StartTime,EndTime,...]   -> for Machine with Index 0 \r\n     *  [jobId,StartTime,EndTime,...]   -> for Machine with Index 1\r\n     * ]\r\n     * It is useful to have GanttChart in this format because it lets us \r\n     * read the ganttChart in text format without any special help.\r\n     */\r\n    this.schedule = schedule\r\n    this.getMakeSpan = ()=>{\r\n        /**\r\n         * Calculates MakeSpan of an instance of a JSSP Gantt Chart Solution\r\n         * In our definition of ganttChart, we choose last integer of each array if array>0. \r\n         * and return max of them\r\n         */\r\n        const allEnds = this.schedule.map(arrForMachine => {\r\n            if(!arrForMachine.length || arrForMachine.length === 0){\r\n                return 0\r\n            }\r\n            return arrForMachine[arrForMachine.length -1 ]\r\n        });\r\n        return Math.max(...allEnds)\r\n    }\r\n}\r\n\r\n\r\nfunction JSSP1DEncoding(jobs1d){\r\n    /**\r\n     * Most JSSP problems have way too many ways to run, we need to generate options randomly\r\n     * Since randomly generating options is harder in  2d array while meeting all the constraints\r\n     * we will use a 1D Encoding. We also have functions to convert this into Gantt Chart. \r\n     * \r\n     * This can be represented as a singe array as well.\r\n     */\r\n    this.jssp1d = jobs1d\r\n    // Example jssp1d = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n\r\n    this.JSSP1dToGantt = (jobInstance) => {\r\n        /**\r\n         * Given a 1D solution, convert it into Gantt Chart Solution. \r\n         */\r\n        //const test1D = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n        // const test1D =[0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]\r\n        // const m = 5 // Number of Machines: 0,1,2,3,4,5\r\n        // const n = 4 // Number of Jobs. 0,1,2,3 -> as denoted in the 1d strucutre. \r\n        const ganttChart = []\r\n        for(let i = 0; i<jobInstance.numMachines; i++){\r\n            ganttChart.push([])\r\n        }\r\n        //console.log(ganttChart)\r\n    \r\n        // Next we fill the ganttChart with data based on test1D\r\n        // We need access to the job instance so that we can look at\r\n        \r\n        // Keep Track of last time for each job.\r\n        const lastJobTime = new Array(jobInstance.numJobs).fill(0)\r\n        // console.log(\"Last Job Time\", lastJobTime)\r\n    \r\n        //console.log(jobInstance)\r\n        this.jssp1d.forEach(jobNumber => {\r\n            // job jobNumber is assigned to its respective first. \r\n            const jobDef = jobInstance.jobs[jobNumber]\r\n            // console.log(\"job def is\", jobDef);\r\n            // Get the first one out.\r\n            const firstJob = jobDef.splice(0,2);\r\n            // console.log(`Current Job for Job Number ${jobNumber}  :` ,firstJob)\r\n            const machine = firstJob[0];\r\n            const time = firstJob[1]\r\n    \r\n            // Now fill Gantt Chart\r\n            const firstAvailableTimeOnMachine = ganttChart[machine].length === 0 ? 0 : ganttChart[machine][ganttChart[machine].length -1]\r\n            // What is the last time of dependent job? We can find that out dependent jobs by looking at job instance from before...\r\n            const _lastJobTime = lastJobTime[jobNumber]\r\n            const firstAvailableTime = Math.max(_lastJobTime,firstAvailableTimeOnMachine)\r\n            lastJobTime[jobNumber] = firstAvailableTime+time\r\n            \r\n            const ganttSchedule = [jobNumber,firstAvailableTime+1,firstAvailableTime+time ]\r\n            ganttChart[machine] = [...ganttChart[machine], ...ganttSchedule]\r\n            \r\n        })\r\n    \r\n        //console.log(ganttChart)\r\n\r\n        return new JSSPGanttChartSolution(ganttChart)\r\n    }\r\n}\r\n\r\nfunction FishesYatesShuffle(array) {\r\n    var currentIndex = array.length, temporaryValue, randomIndex;\r\n  \r\n    // While there remain elements to shuffle...\r\n    while (0 !== currentIndex) {\r\n  \r\n      // Pick a remaining element...\r\n      randomIndex = Math.floor(Math.random() * currentIndex);\r\n      currentIndex -= 1;\r\n  \r\n      // And swap it with the current element.\r\n      temporaryValue = array[currentIndex];\r\n      array[currentIndex] = array[randomIndex];\r\n      array[randomIndex] = temporaryValue;\r\n    }\r\n  \r\n    return array;\r\n}\r\n\r\nfunction generateRandom1D(numMachines, numJobs) {\r\n    // We want each jobs repetead numMachines of times. \r\n    let jobs = []\r\n    for(let i = 0;i < numJobs; i++){\r\n        const values = new Array(numMachines).fill(i) // Fill with Job Number \r\n        jobs = [...jobs, ...values]\r\n    }\r\n    const jssp1d = new JSSP1DEncoding(FishesYatesShuffle(jobs))\r\n    return jssp1d\r\n    console.log(jobs)\r\n}\r\n\r\nexport {\r\n    JSSPProblemInstance,\r\n    JSSPGanttChartSolution,\r\n    JSSP1DEncoding,\r\n    FishesYatesShuffle,\r\n    generateRandom1D\r\n}","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}