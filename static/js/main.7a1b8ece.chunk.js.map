{"version":3,"sources":["logo.svg","GanttMachineSchedule.js","GanttXTicks.js","GattChart.js","JSSP.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","GanttMachineSchedule","props","Math","floor","random","jobid","str","hash","i","length","charCodeAt","colour","toString","substr","a","this","schedule","start","end","_width","maxTime","_startpx","style","width","height","backgroundColor","jobIdToColour","position","left","transition","id","index","className","data-start","data-end","data-jobid","push","parentStyle","display","top","React","Component","GanttXTicks","ticks","maxTimePlus","tick","GanttChart","console","log","allEnds","map","schArr","max","sch","idx","JSSPGanttChartSolution","getMakeSpan","arrForMachine","JSSP1DEncoding","jobs1d","jssp1d","JSSP1dToGantt","jobInstance","ganttChart","numMachines","lastJobTime","Array","numJobs","fill","forEach","jobNumber","firstJob","jobs","splice","machine","time","firstAvailableTimeOnMachine","_lastJobTime","firstAvailableTime","ganttSchedule","generateRandom1D","values","array","temporaryValue","randomIndex","currentIndex","FishesYatesShuffle","problem","n","m","App","state","makeSpan","Infinity","runOptimizationAlgo","algorithmRepetition","algorithmMaxTimeSecs","algoMaxEndTime","Date","getTime","randomizedInput","problemCopy","Object","assign","JSON","parse","stringify","ganttFromRandInput","newMakeSpan","setState","setTimeout","class","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"qKAAAA,EAAOC,QAAU,IAA0B,kC,0JCqE5BC,E,YA/DX,WAAYC,GAAO,qEACTA,I,yEAQN,OAAOC,KAAKC,MAAsB,IAAhBD,KAAKE,Y,oCAIbC,GAGV,IAFA,IAAMC,EAAG,UAAMD,EAAN,SACLE,EAAO,EACFC,EAAI,EAAGA,EAAIF,EAAIG,OAAQD,IAC5BD,EAAOD,EAAII,WAAWF,KAAOD,GAAQ,GAAKA,GAE9C,IAAII,EAAS,IACb,IAASH,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAExBG,IAAW,MADEJ,GAAa,EAAJC,EAAU,KACRI,SAAS,KAAKC,QAAQ,GAElD,OAAOF,I,+BAIP,IADA,IAAIG,EAAI,GACAN,EAAI,EAAGA,EAAGO,KAAKd,MAAMe,SAASP,OAAQD,IAC1C,GAAGA,EAAE,IAAM,EAAE,CACT,IAAMH,EAAQU,KAAKd,MAAMe,SAASR,GAC5BS,EAAQF,KAAKd,MAAMe,SAASR,EAAI,GAChCU,EAAMH,KAAKd,MAAMe,SAASR,EAAI,GAC9BW,EAAS,KAAMD,EAAMD,GAAOF,KAAKd,MAAMmB,QACvCC,EAAW,IAAKJ,EAAQF,KAAKd,MAAMmB,QACnCE,EAAQ,CACVC,MAAM,GAAD,OAAIJ,EAAJ,KACLK,OAAQ,OAERC,gBAAgB,GAAD,OAAIV,KAAKW,cAAcrB,IACtCsB,SAAS,WACTC,KAAK,GAAD,OAAIP,EAAJ,KACJQ,WAAY,iBAGVN,EAAQ,yBAAKO,GAAE,cAASf,KAAKd,MAAM8B,MAApB,YAA6B1B,GAAS2B,UAAS,cAAS3B,GAAUiB,MAAOA,EAAOW,aAAYhB,EAAOiB,WAAUhB,EAAKiB,aAAY9B,GAArI,OAAiJA,GAC/JS,EAAEsB,KAAKb,GAIf,IAAMc,EAAc,CAChBV,SAAS,WACTW,QAAQ,OACRC,IAAI,GAAD,OAAuB,GAAnBxB,KAAKd,MAAM8B,MAAf,OAEP,OACI,yBAAKT,MAAOe,GACPvB,O,GA1DkB0B,IAAMC,WC8B1BC,E,iLAvBP,IARA,IAAML,EAAc,CAChBV,SAAS,WAETY,IAAI,GAAD,OAAyB,GAApBxB,KAAKd,MAAM8B,MAAhB,OAGDY,EAAQ,GACRC,EAA2C,IAA3B7B,KAAKd,MAAMmB,QAAQ,GAAI,GACrCZ,EAAI,EAAGA,EAAEoC,EAAapC,IAAI,CAC9B,IAAMa,EAAW,IAAKb,EAAIO,KAAKd,MAAMmB,QAC/BE,EAAQ,CACVM,KAAK,GAAD,OAAIP,EAAJ,KACJQ,WAAY,gBACZF,SAAS,YAEb,GAAGnB,EAAE,KAAO,EAAE,CACV,IAAMqC,EAAO,0BAAMvB,MAAOA,GACtB,kCACA,6BAAMd,IAEVmC,EAAMP,KAAKS,IAGnB,OACI,yBAAKvB,MAAOe,GACPM,O,GA3BSH,IAAMC,WC+CjBK,E,iLAnCPC,QAAQC,IAAIjC,KAAKd,OACjB,IAAMgD,EAAUlC,KAAKd,MAAMe,SAASkC,KAAI,SAAAC,GAAM,OAAIA,EAAOA,EAAO1C,OAAO,MACvEsC,QAAQC,IAAIC,GACZ,IAAM7B,EAAUlB,KAAKkD,IAAL,MAAAlD,KAAI,YAAQ+C,IAC5B,OACI,oCAaA,yBAAKjB,UAAU,mBACX,yBAAKA,UAAU,mBACVjB,KAAKd,MAAMe,SAASkC,KAAK,SAACG,EAAIC,GAC3B,OAAO,0BAAMtB,UAAU,aAAhB,kBAAwCsB,EAAI,QAI3D,yBAAKtB,UAAU,kBACVjB,KAAKd,MAAMe,SAASkC,KAAK,SAACG,EAAIC,GAAL,OACtB,kBAAC,EAAD,CAAsBtC,SAAUqC,EAAKjC,QAASA,EAASW,MAAOuB,OAClE,kBAAC,EAAD,CAAavB,MAAOhB,KAAKd,MAAMe,SAASP,OAAQW,QAASA,W,GA9BpDoB,IAAMC,WCe/B,SAASc,EAAuBvC,GAAU,IAAD,OAUrCD,KAAKC,SAAWA,EAChBD,KAAKyC,YAAc,WAMf,IAAMP,EAAU,EAAKjC,SAASkC,KAAI,SAAAO,GAC9B,OAAIA,EAAchD,QAAmC,IAAzBgD,EAAchD,OAGnCgD,EAAcA,EAAchD,OAAQ,GAFhC,KAIf,OAAOP,KAAKkD,IAAL,MAAAlD,KAAI,YAAQ+C,KAK3B,SAASS,EAAeC,GAAQ,IAAD,OAQ3B5C,KAAK6C,OAASD,EAGd5C,KAAK8C,cAAgB,SAACC,GASlB,IADA,IAAMC,EAAa,GACXvD,EAAI,EAAGA,EAAEsD,EAAYE,YAAaxD,IACtCuD,EAAW3B,KAAK,IAQpB,IAAM6B,EAAc,IAAIC,MAAMJ,EAAYK,SAASC,KAAK,GA4BxD,OAxBA,EAAKR,OAAOS,SAAQ,SAAAC,GAEhB,IAGMC,EAHST,EAAYU,KAAKF,GAGRG,OAAO,EAAE,GAE3BC,EAAUH,EAAS,GACnBI,EAAOJ,EAAS,GAGhBK,EAA6D,IAA/Bb,EAAWW,GAASjE,OAAe,EAAIsD,EAAWW,GAASX,EAAWW,GAASjE,OAAQ,GAErHoE,EAAeZ,EAAYK,GAC3BQ,EAAqB5E,KAAKkD,IAAIyB,EAAaD,GACjDX,EAAYK,GAAaQ,EAAmBH,EAE5C,IAAMI,EAAgB,CAACT,EAAUQ,EAAmB,EAAEA,EAAmBH,GACzEZ,EAAWW,GAAX,sBAA0BX,EAAWW,IAAaK,MAM/C,IAAIxB,EAAuBQ,IAuB1C,SAASiB,EAAiBhB,EAAaG,GAGnC,IADA,IAAIK,EAAO,GACHhE,EAAI,EAAEA,EAAI2D,EAAS3D,IAAI,CAC3B,IAAMyE,EAAS,IAAIf,MAAMF,GAAaI,KAAK5D,GAC3CgE,EAAI,sBAAOA,GAAP,YAAgBS,IAGxB,OADe,IAAIvB,EA1BvB,SAA4BwB,GAIxB,IAHA,IAAiCC,EAAgBC,EAA7CC,EAAeH,EAAMzE,OAGlB,IAAM4E,GAGXD,EAAclF,KAAKC,MAAMD,KAAKE,SAAWiF,GAIzCF,EAAiBD,EAHjBG,GAAgB,GAIhBH,EAAMG,GAAgBH,EAAME,GAC5BF,EAAME,GAAeD,EAGvB,OAAOD,EAU2BI,CAAmBd,IC/HzD,IAKMe,EAAU,IDpBhB,SAA6BC,EAAEC,GAC3B1E,KAAKoD,QAAUqB,EACfzE,KAAKiD,YAAcyB,EACnB1E,KAAKyD,KAAO,GCiBA,CAAwB,EAAE,GAC1Ce,EAAQf,KAAO,CACb,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,IACjC,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,IACjC,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,IACjC,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,K,IAqGpBkB,E,YAlGb,WAAYzF,GAAO,IAAD,8BAChB,4CAAMA,KACD0F,MAAQ,CACX3E,SAAS,CAAC,GAAG,IACb4E,SAASC,KAEX,EAAKC,oBAAoBP,EAAS,GAAI,GANtB,E,iFASEA,EAASQ,EAAqBC,GAMhD,IANuE,IAAD,OAEhEJ,EAAa7E,KAAK4E,MAAlBC,SAGAK,GADiB,IAAIC,MAAMC,UAC8B,IAAvBH,EAChCxF,EAAI,EAAGA,EAAIuF,EAAqBvF,IAAK,CAEzC,GADFuC,QAAQC,IAAI,gBACLxC,EAAE,KAAK,IAAO,IAAI0F,MAAMC,UAAYF,EAAe,CACpDlD,QAAQC,IAAI,gCACZD,QAAQC,IAAI,eAAiBxC,GAC7B,MAEJ,IAAM4F,EAAkBpB,EAAiBO,EAAQvB,YAAauB,EAAQpB,SAChEkC,EAAcC,OAAOC,OAAO,GAAIhB,GACtCc,EAAY7B,KAAOgC,KAAKC,MAAMD,KAAKE,UAAUnB,EAAQf,OAErD,IAAMmC,EAAqBP,EAAgBvC,cAAcwC,GACnDO,EAAcD,EAAmBnD,cAGpCoD,EAAchB,IACbA,EAAWgB,EAEX7D,QAAQC,IAAI,eAAgB2D,GAC5B5D,QAAQC,IAAI,0BAA2BxC,EAAGoG,GAC1C7F,KAAK8F,SAAS,CACZ7F,SAAS2F,EAAmB3F,SAC5B4E,SAASA,KAMnBkB,YAAY,WAAO,EAAKhB,oBAAoBP,EAAS,EAAG,KAAI,O,+BAK5D,OADAxC,QAAQC,IAAI,6BAA8BjC,KAAK4E,MAAM3E,UAEnD,yBAAKgB,UAAU,OACb,8BACE,yBAAK+E,MAAM,UACT,yBAAKA,MAAM,aAAX,mCACA,yBAAKA,MAAM,YACT,yBAAKA,MAAM,kBAAX,uCACA,yBAAKA,MAAM,kBAAX,iCAGJ,yBAAKA,MAAM,cACT,yBAAKA,MAAM,kBAAX,sBAGJ,4DACA,kBAAC,EAAD,CAAY/F,SAAUD,KAAK4E,MAAM3E,WACjC,yBAAKgB,UAAU,eACb,6BACA,uDACA,+OAGA,0FAEV,wDACA,8CACA,oCACA,yDACA,yDACA,yDACA,yDACA,yDATU,ohB,GAvEQQ,IAAMC,WCfJuE,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.7a1b8ece.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.25bf045c.svg\";","import React from 'react';\r\n\r\n/**\r\n * Idea here is to take an array\r\n */\r\nclass GanttMachineSchedule extends React.Component {\r\n    constructor(props){\r\n        super(props)\r\n        // this.state = {\r\n        //     schedule : this.props.schedule,// [ 0, 1, 10, 1, 21, 30, 2, 131, 140, 3, 146, 165 ],\r\n        //     maxTime: this.props.maxTime,//165\r\n        //     index: this.props.index\r\n        // }\r\n    }\r\n    randColor(){\r\n        return Math.floor(Math.random() * 180) //use 180 instead of 255 to avoid colors too light\r\n    }\r\n\r\n    // Modified from https://stackoverflow.com/questions/3426404/create-a-hexadecimal-colour-based-on-a-string-with-javascript\r\n    jobIdToColour(jobid) {\r\n        const str = `${jobid}color`\r\n        var hash = 0;\r\n        for (var i = 0; i < str.length; i++) {\r\n            hash = str.charCodeAt(i) + ((hash << 5) - hash);\r\n        }\r\n        var colour = '#';\r\n        for (var i = 0; i < 3; i++) {\r\n            var value = (hash >> (i * 8)) & 0xFF;\r\n            colour += ('00' + value.toString(16)).substr(-2);\r\n        }\r\n        return colour;\r\n    }\r\n    render(){\r\n        let a = [] \r\n        for(let i = 0; i< this.props.schedule.length; i++){\r\n            if(i%3 === 0){\r\n                const jobid = this.props.schedule[i];\r\n                const start = this.props.schedule[i + 1];\r\n                const end = this.props.schedule[i + 2];\r\n                const _width = 100* (end - start)/this.props.maxTime\r\n                const _startpx = 100* start / this.props.maxTime\r\n                const style = {\r\n                    width:`${_width}%`,\r\n                    height: '20px',\r\n                    // border:'black',\r\n                    backgroundColor:`${this.jobIdToColour(jobid)}`,\r\n                    position:'absolute',\r\n                    left:`${_startpx}%`,\r\n                    transition: 'all 1s linear'\r\n                }\r\n\r\n                const width = <div id={`key-${this.props.index}-${jobid}`} className={`job-${jobid}`}  style={style} data-start={start} data-end={end} data-jobid={jobid}>Job-{jobid}</div>\r\n                a.push(width)\r\n            }\r\n            continue\r\n        }\r\n        const parentStyle = {\r\n            position:'relative',\r\n            display:'flex',\r\n            top:`${this.props.index * 25}px`\r\n        }\r\n        return (\r\n            <div style={parentStyle}>\r\n                {a}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GanttMachineSchedule","import React from 'react';\r\n\r\nclass GanttXTicks extends React.Component {\r\n    render(){\r\n        const parentStyle = {\r\n            position:'relative',\r\n            // display:'flex',\r\n            top:`${(this.props.index) * 25}px`,\r\n            // width: '100%'\r\n        }\r\n        const ticks = []\r\n        const maxTimePlus = ((this.props.maxTime/10)+1 )*10\r\n        for(let i = 0; i<maxTimePlus; i++){\r\n            const _startpx = 100* i / this.props.maxTime\r\n            const style = {\r\n                left:`${_startpx}%`,\r\n                transition: 'all 1s linear',\r\n                position:'absolute'\r\n            }\r\n            if(i%10 === 0){\r\n                const tick = <span style={style}>\r\n                    <div>|</div>\r\n                    <div>{i}</div>\r\n                    </span>\r\n                ticks.push(tick);\r\n            }\r\n        }\r\n        return (\r\n            <div style={parentStyle}>\r\n                {ticks}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GanttXTicks","import React from 'react';\r\nimport GanttMachineSchedule from './GanttMachineSchedule';\r\nimport GanttXTicks from './GanttXTicks';\r\n\r\n// this.state =  {\r\n//     schedule:this.props.schedule\r\n//     // ? this.props.schedule :  [ [ 0, 1, 10, 1, 21, 30, 2, 131, 140, 3, 146, 165 ],\r\n//     // [ 1, 1, 20, 0, 21, 40, 2, 41, 60, 3, 166, 180 ],\r\n//     // [ 2, 1, 30, 1, 61, 110, 0, 111, 130, 3, 131, 145 ],\r\n//     // [ 1, 31, 60, 3, 61, 90, 2, 91, 130, 0, 131, 170 ],\r\n//     // [ 3, 1, 50, 2, 61, 72, 1, 111, 140, 0, 171, 180 ] ]\r\n// }\r\nclass GanttChart extends React.Component {\r\n    render(){\r\n        console.log(this.props)\r\n        const allEnds = this.props.schedule.map(schArr => schArr[schArr.length-1])\r\n        console.log(allEnds)\r\n        const maxTime = Math.max(...allEnds)\r\n        return (\r\n            <>\r\n            {/* <table>\r\n                <tbody>\r\n                    <tr>\r\n                        <td>test</td>\r\n                        <td>test2</td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>abother test</td>\r\n                        <td>abother test</td>\r\n                    </tr>\r\n                </tbody>\r\n            </table> */}\r\n            <div className=\"ganttChartWithY\">\r\n                <div className=\"ganttChartYAxis\">\r\n                    {this.props.schedule.map( (sch,idx)=>{\r\n                        return <span className=\"yAxisTick\">{`Machine ${idx+1}`}</span>\r\n                    })}\r\n\r\n                </div>\r\n                <div className=\"ganttChartData\">\r\n                    {this.props.schedule.map( (sch,idx) => \r\n                        <GanttMachineSchedule schedule={sch} maxTime={maxTime} index={idx}/>)}\r\n                    <GanttXTicks index={this.props.schedule.length} maxTime={maxTime} />\r\n                </div>\r\n            </div>\r\n            </>\r\n        )\r\n    }\r\n}\r\nexport default GanttChart","function JSSPProblemInstance(n,m){\r\n    this.numJobs = n;\r\n    this.numMachines = m\r\n    this.jobs = []; // list of lists.\r\n\r\n    // this.generateJSSPFromTextFile = async (filePath) => {\r\n    //     this.jobs = [] // Reset jobs\r\n    //     var lines = require('fs').readFileSync(filePath, 'utf-8').split('\\n')\r\n    //     lines.forEach( (line, index) => {\r\n    //         // console.log(line)\r\n    //         if(index < 2){\r\n    //             //console.log(\"UseLess Line : \", line)\r\n    //         } else if(line.startsWith(\"++\")){\r\n    //             //console.log(\"End\")\r\n    //         } else if (index == 2) {\r\n    //             const split_by_space = line.split(\" \")\r\n    //             this.numJobs = parseInt(split_by_space[0])\r\n    //             this.numMachines = parseInt(split_by_space[1])\r\n    //         } else {\r\n    //             const split_by_space = line.split(\" \")\r\n    //             const machineTimeArr = split_by_space.filter(item => !isNaN(parseInt(item))).map(s => parseInt(s))\r\n    //             this.jobs.push(machineTimeArr)\r\n    //         }\r\n    //     })\r\n    // }\r\n}\r\n\r\nfunction JSSPGanttChartSolution(schedule){\r\n    /**\r\n     * Gantt Chart looks like this:\r\n     * [\r\n     *  [jobId,StartTime,EndTime,jobId,StartTime,EndTime,...]   -> for Machine with Index 0 \r\n     *  [jobId,StartTime,EndTime,...]   -> for Machine with Index 1\r\n     * ]\r\n     * It is useful to have GanttChart in this format because it lets us \r\n     * read the ganttChart in text format without any special help.\r\n     */\r\n    this.schedule = schedule\r\n    this.getMakeSpan = ()=>{\r\n        /**\r\n         * Calculates MakeSpan of an instance of a JSSP Gantt Chart Solution\r\n         * In our definition of ganttChart, we choose last integer of each array if array>0. \r\n         * and return max of them\r\n         */\r\n        const allEnds = this.schedule.map(arrForMachine => {\r\n            if(!arrForMachine.length || arrForMachine.length === 0){\r\n                return 0\r\n            }\r\n            return arrForMachine[arrForMachine.length -1 ]\r\n        });\r\n        return Math.max(...allEnds)\r\n    }\r\n}\r\n\r\n\r\nfunction JSSP1DEncoding(jobs1d){\r\n    /**\r\n     * Most JSSP problems have way too many ways to run, we need to generate options randomly\r\n     * Since randomly generating options is harder in  2d array while meeting all the constraints\r\n     * we will use a 1D Encoding. We also have functions to convert this into Gantt Chart. \r\n     * \r\n     * This can be represented as a singe array as well.\r\n     */\r\n    this.jssp1d = jobs1d\r\n    // Example jssp1d = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n\r\n    this.JSSP1dToGantt = (jobInstance) => {\r\n        /**\r\n         * Given a 1D solution, convert it into Gantt Chart Solution. \r\n         */\r\n        //const test1D = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n        // const test1D =[0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]\r\n        // const m = 5 // Number of Machines: 0,1,2,3,4,5\r\n        // const n = 4 // Number of Jobs. 0,1,2,3 -> as denoted in the 1d strucutre. \r\n        const ganttChart = []\r\n        for(let i = 0; i<jobInstance.numMachines; i++){\r\n            ganttChart.push([])\r\n        }\r\n        //console.log(ganttChart)\r\n    \r\n        // Next we fill the ganttChart with data based on test1D\r\n        // We need access to the job instance so that we can look at\r\n        \r\n        // Keep Track of last time for each job.\r\n        const lastJobTime = new Array(jobInstance.numJobs).fill(0)\r\n        // console.log(\"Last Job Time\", lastJobTime)\r\n    \r\n        //console.log(jobInstance)\r\n        this.jssp1d.forEach(jobNumber => {\r\n            // job jobNumber is assigned to its respective first. \r\n            const jobDef = jobInstance.jobs[jobNumber]\r\n            // console.log(\"job def is\", jobDef);\r\n            // Get the first one out.\r\n            const firstJob = jobDef.splice(0,2);\r\n            // console.log(`Current Job for Job Number ${jobNumber}  :` ,firstJob)\r\n            const machine = firstJob[0];\r\n            const time = firstJob[1]\r\n    \r\n            // Now fill Gantt Chart\r\n            const firstAvailableTimeOnMachine = ganttChart[machine].length === 0 ? 0 : ganttChart[machine][ganttChart[machine].length -1]\r\n            // What is the last time of dependent job? We can find that out dependent jobs by looking at job instance from before...\r\n            const _lastJobTime = lastJobTime[jobNumber]\r\n            const firstAvailableTime = Math.max(_lastJobTime,firstAvailableTimeOnMachine)\r\n            lastJobTime[jobNumber] = firstAvailableTime+time\r\n            \r\n            const ganttSchedule = [jobNumber,firstAvailableTime+1,firstAvailableTime+time ]\r\n            ganttChart[machine] = [...ganttChart[machine], ...ganttSchedule]\r\n            \r\n        })\r\n    \r\n        //console.log(ganttChart)\r\n\r\n        return new JSSPGanttChartSolution(ganttChart)\r\n    }\r\n}\r\n\r\nfunction FishesYatesShuffle(array) {\r\n    var currentIndex = array.length, temporaryValue, randomIndex;\r\n  \r\n    // While there remain elements to shuffle...\r\n    while (0 !== currentIndex) {\r\n  \r\n      // Pick a remaining element...\r\n      randomIndex = Math.floor(Math.random() * currentIndex);\r\n      currentIndex -= 1;\r\n  \r\n      // And swap it with the current element.\r\n      temporaryValue = array[currentIndex];\r\n      array[currentIndex] = array[randomIndex];\r\n      array[randomIndex] = temporaryValue;\r\n    }\r\n  \r\n    return array;\r\n}\r\n\r\nfunction generateRandom1D(numMachines, numJobs) {\r\n    // We want each jobs repetead numMachines of times. \r\n    let jobs = []\r\n    for(let i = 0;i < numJobs; i++){\r\n        const values = new Array(numMachines).fill(i) // Fill with Job Number \r\n        jobs = [...jobs, ...values]\r\n    }\r\n    const jssp1d = new JSSP1DEncoding(FishesYatesShuffle(jobs))\r\n    return jssp1d\r\n    console.log(jobs)\r\n}\r\n\r\nexport {\r\n    JSSPProblemInstance,\r\n    JSSPGanttChartSolution,\r\n    JSSP1DEncoding,\r\n    FishesYatesShuffle,\r\n    generateRandom1D\r\n}","import React from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\nimport GanttChart from './GattChart';\r\nimport GanttMachineSchedule from './GanttMachineSchedule';\r\nimport {\r\n  JSSPProblemInstance,\r\n  JSSPGanttChartSolution,\r\n  JSSP1DEncoding,\r\n  FishesYatesShuffle,\r\n  generateRandom1D\r\n} from './JSSP';\r\n\r\n\r\n// Parameters for algorithm. Problem is defined in a problem definition file.\r\nconst PROBLEM_INSTANCE_FILE = \"demo.txt\"\r\nconst ALGORITHM_REPETITION = 10000\r\nconst ALGORITHM_MAX_TIME_SECONDS = 1  //Max time we want the algo to run. TODO use timelimit\r\n\r\n// Step 1: Create a new instance of JSSPProblemInstance from file.\r\nconst problem = new JSSPProblemInstance(4,5) // Instantiate with no data. \r\nproblem.jobs = [ \r\n  [ 0, 10, 1, 20, 2, 20, 3, 40, 4, 10 ],\r\n  [ 1, 20, 0, 10, 3, 30, 2, 50, 4, 30 ],\r\n  [ 2, 30, 1, 20, 4, 12, 3, 40, 0, 10 ],\r\n  [ 4, 50, 3, 30, 2, 15, 0, 20, 1, 15 ] ]\r\n\r\nclass App extends React.Component {\r\n  constructor(props){\r\n    super(props)\r\n    this.state = {\r\n      schedule:[[],[]],\r\n      makeSpan:Infinity\r\n    }\r\n    this.runOptimizationAlgo(problem, 10, 1)\r\n  }\r\n\r\n  runOptimizationAlgo(problem, algorithmRepetition, algorithmMaxTimeSecs ){\r\n    // let gantt = []\r\n    let { makeSpan } = this.state\r\n    // const times = 100\r\n    const algoStartTime = (new Date).getTime();\r\n    const algoMaxEndTime = algoStartTime + (algorithmMaxTimeSecs * 1000)\r\n    for(let i = 0; i < algorithmRepetition; i ++){\r\n      console.log(\"running algo\")\r\n        if( (i%100==0) && (new Date).getTime() > algoMaxEndTime){ //Run time check every 100th run.\r\n            console.log(\"Ending because of time limit\")\r\n            console.log(\"Ran times : \" , i)\r\n            break;\r\n        }\r\n        const randomizedInput = generateRandom1D(problem.numMachines, problem.numJobs)\r\n        const problemCopy = Object.assign({}, problem)\r\n        problemCopy.jobs = JSON.parse(JSON.stringify(problem.jobs))\r\n\r\n        const ganttFromRandInput = randomizedInput.JSSP1dToGantt(problemCopy)\r\n        const newMakeSpan = ganttFromRandInput.getMakeSpan();\r\n        \r\n        // console.log(ganttFromRandInput.schedule[0])\r\n        if(newMakeSpan < makeSpan){\r\n            makeSpan = newMakeSpan\r\n            // gantt = ganttFromRandInput\r\n            console.log(\"Found Better\", ganttFromRandInput)\r\n            console.log(\"New Make Span at index \", i, newMakeSpan)\r\n            this.setState({\r\n              schedule:ganttFromRandInput.schedule,\r\n              makeSpan:makeSpan\r\n            })\r\n        }\r\n    }\r\n    \r\n    // console.log(\"Shortest MakeSpan\", makeSpan)\r\n    setTimeout( () => {this.runOptimizationAlgo(problem, 1, 1)},1000)\r\n    //return gantt\r\n  }\r\n  render(){\r\n    console.log(\"Render function re-running\", this.state.schedule)\r\n    return (\r\n      <div className=\"App\">\r\n        <main>\r\n          <nav class=\"header\">\r\n            <nav class=\"nav-brand\">Job Shop Optimization Algorithm</nav>\r\n            <div class=\"nav-link\">\r\n              <nav class=\"nav-link__link\">Simple Problem (jobs=4, machines=5)</nav>\r\n              <nav class=\"nav-link__link\">Medium (jobs=5, machines=6)</nav>\r\n            </div>\r\n          </nav>\r\n          <nav class=\"sub-header\">\r\n            <nav class=\"nav-link__link\">Random Algorithm</nav>\r\n          </nav>\r\n        </main>\r\n        <h1>Simple Job Shop Optimization</h1>\r\n        <GanttChart schedule={this.state.schedule}/>\r\n        <div className=\"explanation\">\r\n          <hr></hr>\r\n          <div>How to read the chart?</div>\r\n          <p>Job Shop Problem is a class of problems that help you find the most efficient way of running certain number of jobs on \r\n            a given set of machines. These types of problems regularly arise in manufacturing floors.\r\n          </p>\r\n          <p>The problem solved here has the following problem signature:\r\n            \r\n<div>+++++++++++++++++++++++</div>\r\n<div>A simple Demo</div>\r\n<div>4 5</div>\r\n<div>0 10 1 20 2 20 3 40 4 10</div>\r\n<div>1 20 0 10 3 30 2 50 4 30</div>\r\n<div>2 30 1 20 4 12 3 40 0 10</div>\r\n<div>4 50 3 30 2 15 0 20 1 15</div>\r\n<div>++++++++++++++++++++++++</div>\r\nFirst line with numbers 4 and 5 indicates number of job and number of machine respectively. \r\n\r\nEach line after that indicates a job. First job needs to run on machine 0 for 10 units of time, then on machine 1 for 20 units of time\r\nthen on machine 3 for 40 units of time and so on. \r\n\r\nEach job needs to run in the specific order described in the line. \r\n\r\n\r\nAlgorithm that runs in the background finds the most optimal way of running all the jobs in the given order. \r\n\r\nThe Chart shows the order in which each job must run on each machine. \r\n </p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}