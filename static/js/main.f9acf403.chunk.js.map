{"version":3,"sources":["jobIdToColor.js","GanttMachineSchedule.js","GanttXTicks.js","GattChart.js","worker.js","components/navbar.js","TwoDPlot.js","App.js","JSSP.js","serviceWorker.js","index.js"],"names":["jobIdToColour","jobid","str","hash","i","length","charCodeAt","colour","toString","substr","GanttMachineSchedule","props","Math","floor","random","a","this","schedule","start","end","_width","maxTime","_startpx","style","width","height","backgroundColor","position","left","transition","id","index","className","data-start","data-end","data-jobid","push","parentStyle","display","top","React","Component","GanttXTicks","ticks","maxTimePlus","tick","WATER_BOTTLING_WATER_MACHINES","GanttChart","console","log","allEnds","map","schArr","max","sch","idx","machineName","code","JSSPGanttChartSolution","getMakeSpan","arrForMachine","Infinity","forEach","item","JSSP1DEncoding","jobs1d","jssp1d","JSSP1dToGantt","jobInstance","ganttChart","numMachines","lastJobTime","Array","numJobs","fill","jobNumber","firstJob","jobs","splice","machine","time","firstAvailableTimeOnMachine","_lastJobTime","firstAvailableTime","generateRandom1D","base","nswap","swap","randi","randj","randiVal","j","array","temporaryValue","randomIndex","currentIndex","FishesYatesShuffle","sleep","miliseconds","currentTime","Date","getTime","onmessage","e","data","problem","algorithmRepetition","algorithmMaxTimeSecs","algorithmType","bestSolution1DEncoded","makeSpan","algoMaxEndTime","makeSpanHistory","randomizedInput","problemCopy","Object","assign","JSON","parse","stringify","ganttFromRandInput","newMakeSpan","returnData","type","iteration","postMessage","_runOptimizationAlgo","workerResult","substring","indexOf","lastIndexOf","blob","Blob","worker_script","URL","createObjectURL","NavBar","class","href","data-toggle","data-target","aria-controls","aria-expanded","aria-label","TwoDPlot","val","x","y","title","n","m","App","startJobShopWorker","workerInstance","Worker","WebWorkerScript","addEventListener","setState","iterations","state","minMakeSpanDetectedIteration","maxAlgorithmRepetition","handleChange","event","target","name","value","handleRestartJobShopWorkerButton","preventDefault","terminate","handleStopWorker","screenWidth","window","innerWidth","onChange","placeholder","onClick","marginTop","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f9acf403.chunk.js","sourcesContent":["// Modified from https://stackoverflow.com/questions/3426404/create-a-hexadecimal-colour-based-on-a-string-with-javascript\r\nfunction jobIdToColour(jobid) {\r\n    const str = `${jobid}color`\r\n    var hash = 0;\r\n    for (var i = 0; i < str.length; i++) {\r\n        hash = str.charCodeAt(i) + ((hash << 5) - hash);\r\n    }\r\n    var colour = '#';\r\n    for (var i = 0; i < 3; i++) {\r\n        var value = (hash >> (i * 8)) & 0xFF;\r\n        colour += ('00' + value.toString(16)).substr(-2);\r\n    }\r\n    return colour;\r\n}\r\n\r\nexport default jobIdToColour","import React from 'react';\r\nimport jobIdToColour from './jobIdToColor';\r\n\r\n/**\r\n * Idea here is to take an array\r\n */\r\nclass GanttMachineSchedule extends React.Component {\r\n    constructor(props){\r\n        super(props)\r\n        // this.state = {\r\n        //     schedule : this.props.schedule,// [ 0, 1, 10, 1, 21, 30, 2, 131, 140, 3, 146, 165 ],\r\n        //     maxTime: this.props.maxTime,//165\r\n        //     index: this.props.index\r\n        // }\r\n    }\r\n    randColor(){\r\n        return Math.floor(Math.random() * 180) //use 180 instead of 255 to avoid colors too light\r\n    }\r\n\r\n    // Modified from https://stackoverflow.com/questions/3426404/create-a-hexadecimal-colour-based-on-a-string-with-javascript\r\n    // jobIdToColour(jobid) {\r\n    //     const str = `${jobid}color`\r\n    //     var hash = 0;\r\n    //     for (var i = 0; i < str.length; i++) {\r\n    //         hash = str.charCodeAt(i) + ((hash << 5) - hash);\r\n    //     }\r\n    //     var colour = '#';\r\n    //     for (var i = 0; i < 3; i++) {\r\n    //         var value = (hash >> (i * 8)) & 0xFF;\r\n    //         colour += ('00' + value.toString(16)).substr(-2);\r\n    //     }\r\n    //     return colour;\r\n    // }\r\n    render(){\r\n        let a = [] \r\n        for(let i = 0; i< this.props.schedule.length; i++){\r\n            if(i%3 === 0){\r\n                const jobid = this.props.schedule[i];\r\n                const start = this.props.schedule[i + 1];\r\n                const end = this.props.schedule[i + 2];\r\n                const _width = 100* (end - start)/this.props.maxTime\r\n                const _startpx = 100* start / this.props.maxTime\r\n                const style = {\r\n                    width:`${_width}%`,\r\n                    height: '20px',\r\n                    // border:'black',\r\n                    backgroundColor:`${jobIdToColour(jobid)}`,\r\n                    position:'absolute',\r\n                    left:`${_startpx}%`,\r\n                    transition: 'all 1s linear'\r\n                }\r\n\r\n                const width = <div id={`key-${this.props.index}-${jobid}`} className={`job-${jobid}`}  style={style} data-start={start} data-end={end} data-jobid={jobid}>Job-{jobid}</div>\r\n                a.push(width)\r\n            }\r\n            continue\r\n        }\r\n        const parentStyle = {\r\n            position:'relative',\r\n            display:'flex',\r\n            top:`${this.props.index * 25}px`\r\n        }\r\n        return (\r\n            <div style={parentStyle}>\r\n                {a}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GanttMachineSchedule","import React from 'react';\r\n\r\nclass GanttXTicks extends React.Component {\r\n    render(){\r\n        const parentStyle = {\r\n            position:'relative',\r\n            // display:'flex',\r\n            top:`${(this.props.index) * 25}px`,\r\n            // width: '100%'\r\n        }\r\n        const ticks = []\r\n        const maxTimePlus = ((this.props.maxTime/10)+1 )*10\r\n        for(let i = 0; i<maxTimePlus; i++){\r\n            const _startpx = 100* i / this.props.maxTime\r\n            const style = {\r\n                left:`${_startpx}%`,\r\n                transition: 'all 1s linear',\r\n                position:'absolute'\r\n            }\r\n            if(i%10 === 0){\r\n                const tick = <span style={style}>\r\n                    <div>|</div>\r\n                    <div>{i}</div>\r\n                    </span>\r\n                ticks.push(tick);\r\n            }\r\n        }\r\n        return (\r\n            <div style={parentStyle}>\r\n                {ticks}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GanttXTicks","import React from 'react';\r\nimport GanttMachineSchedule from './GanttMachineSchedule';\r\nimport GanttXTicks from './GanttXTicks';\r\n\r\n// this.state =  {\r\n//     schedule:this.props.schedule\r\n//     // ? this.props.schedule :  [ [ 0, 1, 10, 1, 21, 30, 2, 131, 140, 3, 146, 165 ],\r\n//     // [ 1, 1, 20, 0, 21, 40, 2, 41, 60, 3, 166, 180 ],\r\n//     // [ 2, 1, 30, 1, 61, 110, 0, 111, 130, 3, 131, 145 ],\r\n//     // [ 1, 31, 60, 3, 61, 90, 2, 91, 130, 0, 131, 170 ],\r\n//     // [ 3, 1, 50, 2, 61, 72, 1, 111, 140, 0, 171, 180 ] ]\r\n// }\r\nconst WATER_BOTTLING_WATER_MACHINES = [\r\n    \"Bottle Expansion Mold\",\r\n    \"Water Cleaning/ Purifying\",\r\n    \"Water Filling\",\r\n    \"Bottle Capping\",\r\n    \"Bottle Labeling\"\r\n]\r\nclass GanttChart extends React.Component {\r\n    render(){\r\n        console.log(this.props)\r\n        const allEnds = this.props.schedule.map(schArr => schArr[schArr.length-1])\r\n        console.log(allEnds)\r\n        const maxTime = Math.max(...allEnds)\r\n        const maxTimePlus = ((maxTime/10)+1 )*10\r\n        return (\r\n        \r\n            <div className=\"ganttChartWithY\">\r\n                <div className=\"ganttChartYAxis\">\r\n                    {this.props.schedule.map( (sch,idx)=>{\r\n                        const machineName = WATER_BOTTLING_WATER_MACHINES[idx]\r\n                        return <span className=\"yAxisTick\">{`${machineName} Machine`}</span>\r\n                    })}\r\n\r\n                </div>\r\n                <div className=\"ganttChartData\">\r\n                    {this.props.schedule.map( (sch,idx) => \r\n                        <GanttMachineSchedule schedule={sch} maxTime={maxTime} index={idx}/>)}\r\n                    <GanttXTicks index={this.props.schedule.length} maxTime={maxTime} />\r\n                </div>\r\n            </div>\r\n            \r\n        )\r\n    }\r\n}\r\nexport default GanttChart","import GanttChart from \"./GattChart\";\r\n\r\nconst workercode = () => {\r\n    \r\n    const JSSPProblemInstance = (n,m) => {\r\n        this.numJobs = n;\r\n        this.numMachines = m\r\n        this.jobs = []; // list of lists.\r\n    }\r\n    \r\n    const JSSPGanttChartSolution = function(schedule){\r\n        /**\r\n         * Gantt Chart looks like this:\r\n         * [\r\n         *  [jobId,StartTime,EndTime,jobId,StartTime,EndTime,...]   -> for Machine with Index 0 \r\n         *  [jobId,StartTime,EndTime,...]   -> for Machine with Index 1\r\n         * ]\r\n         * It is useful to have GanttChart in this format because it lets us \r\n         * read the ganttChart in text format without any special help.\r\n         */\r\n        this.schedule = schedule\r\n        this.getMakeSpan = ()=>{\r\n            /**\r\n             * Calculates MakeSpan of an instance of a JSSP Gantt Chart Solution\r\n             * In our definition of ganttChart, we choose last integer of each array if array>0. \r\n             * and return max of them\r\n             */\r\n            const allEnds = this.schedule.map(arrForMachine => {\r\n                if(!arrForMachine.length || arrForMachine.length === 0){\r\n                    return 0\r\n                }\r\n                return arrForMachine[arrForMachine.length -1 ]\r\n            });\r\n            let max = -Infinity;\r\n            allEnds.forEach(item => {\r\n                if(item > max){\r\n                    max = item\r\n                }\r\n            })\r\n            return max\r\n            //return Math.max(...allEnds)\r\n        }\r\n    }\r\n    \r\n    \r\n    function JSSP1DEncoding(jobs1d){\r\n        /**\r\n         * Most JSSP problems have way too many ways to run, we need to generate options randomly\r\n         * Since randomly generating options is harder in  2d array while meeting all the constraints\r\n         * we will use a 1D Encoding. We also have functions to convert this into Gantt Chart. \r\n         * \r\n         * This can be represented as a singe array as well.\r\n         */\r\n        this.jssp1d = jobs1d\r\n        // Example jssp1d = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n    \r\n        this.JSSP1dToGantt = (jobInstance) => {\r\n            /**\r\n             * Given a 1D solution, convert it into Gantt Chart Solution. \r\n             */\r\n            //const test1D = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n            // const test1D =[0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]\r\n            // const m = 5 // Number of Machines: 0,1,2,3,4,5\r\n            // const n = 4 // Number of Jobs. 0,1,2,3 -> as denoted in the 1d strucutre. \r\n            const ganttChart = []\r\n            for(let i = 0; i<jobInstance.numMachines; i++){\r\n                ganttChart.push([])\r\n            }\r\n            //console.log(ganttChart)\r\n        \r\n            // Next we fill the ganttChart with data based on test1D\r\n            // We need access to the job instance so that we can look at\r\n            \r\n            // Keep Track of last time for each job.\r\n            const lastJobTime = new Array(jobInstance.numJobs).fill(0)\r\n            // console.log(\"Last Job Time\", lastJobTime)\r\n        \r\n            //console.log(jobInstance)\r\n            this.jssp1d.forEach(jobNumber => {\r\n                // job jobNumber is assigned to its respective first. \r\n                const jobDef = jobInstance.jobs[jobNumber]\r\n                // console.log(\"job def is\", jobDef);\r\n                // Get the first one out.\r\n                const firstJob = jobDef.splice(0,2);\r\n                // console.log(`Current Job for Job Number ${jobNumber}  :` ,firstJob)\r\n                const machine = firstJob[0];\r\n                const time = firstJob[1]\r\n        \r\n                // Now fill Gantt Chart\r\n                const firstAvailableTimeOnMachine = ganttChart[machine].length === 0 ? 0 : ganttChart[machine][ganttChart[machine].length -1]\r\n                // What is the last time of dependent job? We can find that out dependent jobs by looking at job instance from before...\r\n                const _lastJobTime = lastJobTime[jobNumber]\r\n                const firstAvailableTime = Math.max(_lastJobTime,firstAvailableTimeOnMachine)\r\n                lastJobTime[jobNumber] = firstAvailableTime+time\r\n                \r\n                const ganttSchedule = [jobNumber,firstAvailableTime+1,firstAvailableTime+time ]\r\n                const newList = []\r\n                //ganttChart[machine].forEach(item => newList.push(item))\r\n                ganttSchedule.forEach(item => ganttChart[machine].push(item))\r\n                //ganttChart[machine] = newList // [...ganttChart[machine], ...ganttSchedule]\r\n                \r\n            })\r\n        \r\n            //console.log(ganttChart)\r\n    \r\n            return new JSSPGanttChartSolution(ganttChart)\r\n        }\r\n    }\r\n    \r\n    function FishesYatesShuffle(array) {\r\n        var currentIndex = array.length, temporaryValue, randomIndex;\r\n      \r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n      \r\n          // Pick a remaining element...\r\n          randomIndex = Math.floor(Math.random() * currentIndex);\r\n          currentIndex -= 1;\r\n      \r\n          // And swap it with the current element.\r\n          temporaryValue = array[currentIndex];\r\n          array[currentIndex] = array[randomIndex];\r\n          array[randomIndex] = temporaryValue;\r\n        }\r\n      \r\n        return array;\r\n    }\r\n    \r\n    function generateRandom1D(numMachines, numJobs, base, nswap) {\r\n        if (base){\r\n            // if base is passed in - just do a swap once. nswap not used at the moment.\r\n            console.log(\"base is passed in\")\r\n            console.log(\"base\" , base)\r\n            let randi;\r\n            let randj;\r\n            function swap(){\r\n                const randi = Math.floor(Math.random() * base.length )\r\n                const randj = Math.floor(Math.random() * base.length )\r\n                if(base[randi] == base[randj]){\r\n                    swap()\r\n                }\r\n                const randiVal = base[randi]\r\n                base[randi] = base[randj]\r\n                base[randj] = randiVal\r\n            }\r\n            swap()\r\n            return new JSSP1DEncoding(base) // spread to avoid side effects.\r\n        }\r\n        // We want each jobs repetead numMachines of times. \r\n        let jobs = []\r\n        for(let i = 0;i < numJobs; i++){\r\n            for(let j = 0; j < numMachines; j++){\r\n                jobs.push(i)\r\n            }\r\n            //const values = new Array(numMachines).fill(i) // Fill with Job Number \r\n            //jobs.concat(values)\r\n            //jobs = [...jobs, ...values]\r\n        }\r\n        console.log(\"done creating jobs\")\r\n        console.log(jobs)\r\n        const jssp1d = new JSSP1DEncoding(FishesYatesShuffle(jobs))\r\n        console.log(jssp1d)\r\n        return jssp1d\r\n        console.log(jobs)\r\n    };\r\n    function sleep(miliseconds) { \r\n        /**\r\n         * Evil sleep function used for demoing simulation.\r\n         * Since the example problem I am using solves really fast, I am adding sleep in the thread.\r\n         * TODO >> Actually use setTimeOut to accomplish the same thing so thread isn't running while waiting.\r\n         */\r\n        var currentTime = new Date().getTime();\r\n     \r\n        while (currentTime + miliseconds >= new Date().getTime()) {\r\n        }\r\n     }\r\n     \r\n    function _runOptimizationAlgo(problem, algorithmRepetition, algorithmMaxTimeSecs, algorithmType) {\r\n        console.log(\"inside run optimization , this is \");\r\n        console.log(this);\r\n        console.log(generateRandom1D && \"generate Random 1d is available\")\r\n        let makeSpan = Infinity;\r\n        const algoStartTime = (new Date).getTime();\r\n        const algoMaxEndTime = algoStartTime + (algorithmMaxTimeSecs * 1000)\r\n        const makeSpanHistory = []\r\n        let bestSolution1DEncoded;  // Store the best solution encoded in 1d so far.\r\n        for(let i = 0; i < algorithmRepetition; i ++){\r\n            if( (i%5===0) && (new Date).getTime() > algoMaxEndTime) {\r\n                console.log(\"Ran for too long already\")\r\n                break;\r\n            }\r\n\r\n            if( (i%100==0) && (new Date).getTime() > algoMaxEndTime){ //Run time check every 100th run.\r\n                console.log(\"Ending because of time limit\")\r\n                console.log(\"Ran times : \" , i)\r\n                break;\r\n            }\r\n            const randomizedInput = generateRandom1D(problem.numMachines, problem.numJobs, algorithmType === \"hillClimbing\" ? bestSolution1DEncoded && bestSolution1DEncoded.jssp1d : null)\r\n            const problemCopy = Object.assign({}, problem)\r\n            problemCopy.jobs = JSON.parse(JSON.stringify(problem.jobs))\r\n\r\n            const ganttFromRandInput = randomizedInput.JSSP1dToGantt(problemCopy)\r\n            const newMakeSpan = ganttFromRandInput.getMakeSpan();\r\n            console.log(\"adding to newmakespan from worer\")\r\n            makeSpanHistory.push(newMakeSpan)\r\n            if(i%1  === 0){\r\n                const returnData = {\r\n                    type:'iterationCount',\r\n                    iteration:i+1,\r\n                    newMakeSpan:makeSpanHistory\r\n                }\r\n                this.postMessage(returnData);\r\n                sleep(1*200) // Give UI thread enough time to renderthis.\r\n                makeSpanHistory.length = 0\r\n            }\r\n            \r\n            // console.log(ganttFromRandInput.schedule[0])\r\n            if(newMakeSpan < makeSpan){\r\n                makeSpan = newMakeSpan\r\n                // gantt = ganttFromRandInput\r\n                bestSolution1DEncoded = randomizedInput\r\n                console.log(\"Found Better\", ganttFromRandInput)\r\n                console.log(\"New Make Span at index \", i, newMakeSpan)\r\n                this.postMessage(\"Got New MakeSpan\")\r\n                const returnData = {\r\n                    'type':'newSchedule',\r\n                    'schedule':ganttFromRandInput.schedule,\r\n                    'makeSpan':makeSpan,\r\n                    \"minMakeSpanDetectedIteration\": i\r\n                }\r\n                this.postMessage(returnData);\r\n                sleep(1*1000)\r\n                // this.setState({\r\n                //   schedule:ganttFromRandInput.schedule,\r\n                //   makeSpan:makeSpan\r\n                // })\r\n            }\r\n        }\r\n    }\r\n\r\n    onmessage = function(e) {\r\n        const that = this;\r\n        console.log(\"this inside onmessage\")\r\n        console.log(this)\r\n        console.log('Message received from main script');\r\n        console.log(\"message\", e);\r\n        const { problem, algorithmRepetition, algorithmMaxTimeSecs, algorithmType} = e.data; \r\n        console.log(problem, algorithmMaxTimeSecs);\r\n        _runOptimizationAlgo(problem, algorithmRepetition, algorithmMaxTimeSecs, algorithmType, that)\r\n        var workerResult = 'Received from main: ' + (e.data);\r\n        console.log('Posting message back to main script');\r\n        this.postMessage(workerResult);\r\n    }\r\n\r\n    \r\n};\r\n\r\nlet code = workercode.toString();\r\ncode = code.substring(code.indexOf(\"{\")+1, code.lastIndexOf(\"}\"));\r\n\r\nconst blob = new Blob([code], {type: \"application/javascript\"});\r\nconst worker_script = URL.createObjectURL(blob);\r\n\r\nexport default worker_script;\r\n//module.exports = worker_script;\r\n\r\n\r\n// const runOptimizationAlgo = (problem, algorithmRepetition, algorithmMaxTimeSecs, workerInstance ) => {\r\n//     // let gantt = []\r\n//     let { makeSpan } = this.state\r\n//     // const times = 100\r\n//     const algoStartTime = (new Date).getTime();\r\n//     const algoMaxEndTime = algoStartTime + (algorithmMaxTimeSecs * 1000)\r\n//     for(let i = 0; i < algorithmRepetition; i ++){\r\n//       console.log(\"running algo\")\r\n//       workerInstance.postMessage(`Iteration : ${i}`)\r\n//         if( (i%100==0) && (new Date).getTime() > algoMaxEndTime){ //Run time check every 100th run.\r\n//             console.log(\"Ending because of time limit\")\r\n//             console.log(\"Ran times : \" , i)\r\n//             break;\r\n//         }\r\n//         const randomizedInput = generateRandom1D(problem.numMachines, problem.numJobs)\r\n//         const problemCopy = Object.assign({}, problem)\r\n//         problemCopy.jobs = JSON.parse(JSON.stringify(problem.jobs))\r\n\r\n//         const ganttFromRandInput = randomizedInput.JSSP1dToGantt(problemCopy)\r\n//         const newMakeSpan = ganttFromRandInput.getMakeSpan();\r\n        \r\n//         // console.log(ganttFromRandInput.schedule[0])\r\n//         if(newMakeSpan < makeSpan){\r\n//             makeSpan = newMakeSpan\r\n//             // gantt = ganttFromRandInput\r\n//             //console.log(\"Found Better\", ganttFromRandInput)\r\n//             console.log(\"New Make Span at index \", i, newMakeSpan)\r\n//             workerInstance.postMessage(\"Got New MakeSpan\")\r\n//             workerInstance.postMessage(makeSpan)\r\n//             // this.setState({\r\n//             //   schedule:ganttFromRandInput.schedule,\r\n//             //   makeSpan:makeSpan\r\n//             // })\r\n//         }\r\n//     }\r\n// }","import React from 'react'\r\nfunction NavBar(props){\r\n    return (\r\n        <nav class=\"navbar navbar-expand-lg navbar-dark bg-primary\">\r\n            <a class=\"navbar-brand\" href=\"/\">Job Shop Problem Demo</a>\r\n            <button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\r\n                <span class=\"navbar-toggler-icon\"></span>\r\n            </button>\r\n\r\n            <div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\r\n                <ul class=\"navbar-nav mr-auto\">\r\n                    <li class=\"nav-item active\">\r\n                        <a class=\"nav-link\" href=\"/\">Water Bottle Plant Example <span class=\"sr-only\">(current)</span></a>\r\n                    </li>\r\n                    \r\n                </ul>\r\n            </div>\r\n        </nav>\r\n    )\r\n}\r\n\r\nfunction SubNavBar(props){\r\n    return (\r\n        <nav class=\"navbar navbar-expand-lg navbar-light bg-light\">\r\n            <div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\r\n                <ul class=\"navbar-nav mr-auto\">\r\n                    <li class=\"nav-item active\">\r\n                        <a class=\"nav-link\" href=\"/\">Random Algorithm <span class=\"sr-only\">(current)</span></a>\r\n                    </li>\r\n                    <li class=\"nav-item\">\r\n                        <a disabled class=\"nav-link\" href=\"/\">Neighbourhood search algorithm (Coming Soon)</a>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </nav>\r\n    )\r\n}\r\n\r\nexport { NavBar, SubNavBar }","import React, { Component } from 'react';\r\nimport './App.css';\r\nimport '../node_modules/react-vis/dist/style.css';\r\nimport {XYPlot, LineSeries, HorizontalGridLines, VerticalGridLines, XAxis, YAxis} from 'react-vis';\r\n\r\nclass TwoDPlot extends Component {\r\n  render() {\r\n    console.log(this.props);\r\n    // Get props.data = [123,345,345,999 ...] from parent. \r\n    const data = this.props.data.map((val,idx)=>{\r\n      return {\r\n        x: idx,\r\n        y: val\r\n      }\r\n    })\r\n    // const data = [\r\n    //   {x: 0, y: 8},\r\n    //   {x: 1, y: 5},\r\n    //   {x: 2, y: 4},\r\n    //   {x: 3, y: 9},\r\n    //   {x: 4, y: 1},\r\n    //   {x: 5, y: 7},\r\n    //   {x: 6, y: 6},\r\n    //   {x: 7, y: 3},\r\n    //   {x: 8, y: 2},\r\n    //   {x: 9, y: 0}\r\n    // ];\r\n    return (\r\n      <div className=\"twodplot\">\r\n        <div>\r\n          <XYPlot height={this.props.height || 300} width={this.props.width || 300}>\r\n            <LineSeries data={data} />\r\n            <XAxis title=\"Number of Iterations\" />\r\n            <YAxis title=\"MakeSpan\" />\r\n            <VerticalGridLines />\r\n            <HorizontalGridLines />\r\n          </XYPlot>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default TwoDPlot","import React from 'react';\r\nimport './App.css';\r\nimport GanttChart from './GattChart';\r\nimport jobIdToColour from './jobIdToColor';\r\nimport WebWorkerScript from './worker';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport {\r\n  JSSPProblemInstance,\r\n  JSSPGanttChartSolution,\r\n  JSSP1DEncoding,\r\n  FishesYatesShuffle,\r\n  generateRandom1D\r\n} from './JSSP';\r\nimport { NavBar , SubNavBar } from './components/navbar';\r\nimport TwoDPlot from './TwoDPlot';\r\n\r\n\r\n// Parameters for algorithm. Problem is defined in a problem definition file.\r\nconst PROBLEM_INSTANCE_FILE = \"demo.txt\"\r\nconst ALGORITHM_REPETITION = 10000\r\nconst ALGORITHM_MAX_TIME_SECONDS = 1  //Max time we want the algo to run. TODO use timelimit\r\n\r\n// A more complicated Example:\r\n\r\n\r\n\r\n// Step 1: Create a new instance of JSSPProblemInstance from file.\r\nconst problem = new JSSPProblemInstance(4,5) // Instantiate with no data. \r\n\r\n// // Example Problem Statement\r\n// problem.jobs = [ \r\n//   [ 0, 10, 1, 20, 2, 20, 3, 40, 4, 10 ],\r\n//   [ 1, 20, 0, 10, 3, 30, 2, 50, 4, 30 ],\r\n//   [ 2, 30, 1, 20, 4, 12, 3, 40, 0, 10 ],\r\n//   [ 4, 50, 3, 30, 2, 15, 0, 20, 1, 15 ] ]\r\n\r\n// Complicated Problem Statement\r\n// problem.numJobs = 10\r\n// problem.numMachines = 10\r\n// problem.jobs = [\r\n// [ 4, 88, 8, 68, 6, 94, 5, 99, 1, 67, 2, 89, 9, 77, 7, 99, 0, 86, 3, 92 ],\r\n// [ 5, 72, 3, 50, 6, 69, 4, 75, 2, 94, 8, 66, 0, 92, 1, 82, 7, 94, 9, 63 ],\r\n// [ 9, 83, 8, 61, 0, 83, 1, 65, 6, 64, 5, 85, 7, 78, 4, 85, 2, 55, 3, 77 ],\r\n// [ 7, 94, 2, 68, 1, 61, 4, 99, 3, 54, 6, 75, 5, 66, 0, 76, 9, 63, 8, 67 ],\r\n// [ 3, 69, 4, 88, 9, 82, 8, 95, 0, 99, 2, 67, 6, 95, 5, 68, 7, 67, 1, 86 ],\r\n// [ 1, 99, 4, 81, 5, 64, 6, 66, 8, 80, 2, 80, 7, 69, 9, 62, 3, 79, 0, 88 ],\r\n// [ 7, 50, 1, 86, 4, 97, 3, 96, 0, 95, 8, 97, 2, 66, 5, 99, 6, 52, 9, 71 ],\r\n// [ 4, 98, 6, 73, 3, 82, 2, 51, 1, 71, 5, 94, 7, 85, 0, 62, 8, 95, 9, 79 ],\r\n// [ 0, 94, 6, 71, 3, 81, 7, 85, 1, 66, 2, 90, 4, 76, 5, 58, 8, 93, 9, 97 ],\r\n// [ 3, 50, 0, 59, 1, 82, 8, 67, 7, 56, 9, 96, 6, 58, 4, 81, 5, 59, 2, 96 ]\r\n// ]\r\n\r\n\r\n\r\n\r\n/**\r\n * Water Bottoling Plant that does 4 different types of water bottles. \r\n * Job 0 - Spring Water 16oz\r\n * Job 1 - Distilled Water 16 oz\r\n * Job 2 - Distilled Water 32 oz\r\n * Job 4 - Bottoled Water 32 oz\r\n * \r\n * We have 5 machines for different operations\r\n * Machine 0 - Bottle Expansion Molding\r\n * Machine 1 - Water Cleaning or purifying Machine \r\n * Machine 2 - Pouring water / Filling Process \r\n * Machine 3 - Capping\r\n * Machine 4 - Labelling\r\n * \r\n * Jobs must be run in the following order\r\n */\r\nproblem.jobs = [\r\n  [0, 10, 1, 10, 2, 10, 3, 10, 4, 8],\r\n  [0, 50, 1, 15, 2, 10, 3, 10, 4, 16],\r\n  [0, 30, 1, 12, 2, 20, 3, 10, 4, 16],\r\n  [0, 15, 1, 30, 2, 20, 3, 10, 4, 10],\r\n]\r\n\r\nclass App extends React.Component {\r\n  constructor(props){\r\n    super(props)\r\n    this.state = {\r\n      schedule:[[],[]],\r\n      makeSpan:Infinity,\r\n      minMakeSpanDetectedIteration:0,\r\n      iterations:0,\r\n      workerInstance : new Worker(WebWorkerScript),\r\n      makeSpanHistory:[],\r\n      maxAlgorithmRepetition:50,\r\n      algorithmMaxTimeSecs:30,\r\n      algorithmType: 'hillClimbing' // random || hillClimbing\r\n    }\r\n    //this.runOptimizationAlgo(problem, 10, 1)\r\n    // setTimeout( () => {this.runOptimizationAlgo(problem, 1, 1)},1000)\r\n  }\r\n  startJobShopWorker = () => {\r\n    //var myWorker = new Worker('worker.js');\r\n    const workerInstance = new Worker(WebWorkerScript);\r\n    \r\n    workerInstance.addEventListener(\"message\", e => {\r\n      console.log(\"Received response:\");\r\n      console.log(e.data);\r\n      // We can have 2 different data types.\r\n      // {\"type\":\"iterationCount\",\"value\":200}\r\n      // {\"type\":\"newSchedule\",\"value\":[[],...]}\r\n      if(e.data && e.data.type === \"iterationCount\"){\r\n        //console.log(`New Iteration Count ${e.data.value}`)\r\n        console.log(\"About to concate makeSpan history array\")\r\n        this.setState({\r\n          iterations:e.data.iteration,\r\n          makeSpanHistory:[...this.state.makeSpanHistory,...e.data.newMakeSpan]\r\n        })\r\n      }\r\n      else if(e.data && e.data.type === \"newSchedule\"){\r\n        console.log(`New Schedule ${e.data.schedule}`)\r\n        this.setState({\r\n          schedule : e.data.schedule, makeSpan:e.data.makeSpan,\r\n          minMakeSpanDetectedIteration: e.data.minMakeSpanDetectedIteration\r\n        });\r\n      } else {\r\n        console.log(\"generic Message \", e.data);\r\n      } \r\n    }, false);\r\n    \r\n    workerInstance.postMessage({\r\n      algorithmRepetition:this.state.maxAlgorithmRepetition,\r\n      problem:problem,\r\n      algorithmMaxTimeSecs:this.state.algorithmMaxTimeSecs,\r\n      algorithmType: this.state.algorithmType\r\n    })\r\n\r\n    this.setState({\r\n      workerInstance: workerInstance,\r\n    })\r\n  }\r\n\r\n  componentDidMount(){\r\n    //console.log(\"component did mount activated\")\r\n    this.startJobShopWorker()\r\n  }\r\n  handleChange = (event)=>{\r\n    this.setState({[event.target.name]: event.target.value});\r\n  }\r\n\r\n  handleRestartJobShopWorkerButton = (e)=>{\r\n    e.preventDefault();\r\n    console.log(\"restarting this puppy.\")\r\n    console.log(e)\r\n    this.state.workerInstance.terminate();\r\n    this.setState({\r\n      schedule:[[],[]],\r\n      makeSpan:Infinity,\r\n      minMakeSpanDetectedIteration:0,\r\n      iterations:0,\r\n      makeSpanHistory:[],\r\n    },this.startJobShopWorker() )\r\n    \r\n  }\r\n  handleStopWorker = (e) => {\r\n    console.log(\"terminate worker\")\r\n    this.state.workerInstance.terminate();\r\n    console.log(\"terminate complete\")\r\n  }\r\n  render(){\r\n    console.log(\"Render function re-running\", this.state.schedule)\r\n    const screenWidth = (window.innerWidth - 60)\r\n    return (\r\n      <div className=\"App\">\r\n        <NavBar/>\r\n        <h3>Water Bottling Plant - MakeSpan Optimization</h3>\r\n        <p>\r\n          <strong>Number of Simulations Performed:</strong> {this.state.iterations}  | \r\n          <strong>Minimum MakeSpan detected:</strong> {this.state.makeSpan} | <strong>Min detected after iteration :</strong> {this.state.minMakeSpanDetectedIteration}\r\n        </p>\r\n        <h6>Terminates after running \r\n          <input type=\"number\" style={{width:'4em'}} name=\"maxAlgorithmRepetition\" onChange={this.handleChange} value={this.state.maxAlgorithmRepetition}/>\r\n          simulations or after \r\n          \r\n          <input type=\"number\" style={{width:'4em'}} name=\"algorithmMaxTimeSecs\" onChange={this.handleChange} value={this.state.algorithmMaxTimeSecs} class=\"form-controll\" placeholder=\"Max number of iterations\"/>\r\n          seconds has passed or when \r\n          <button className=\"ml-2\" onClick={this.handleStopWorker}> Stop </button>\r\n          is clicked.\r\n\r\n          Uses \r\n          <select className=\"form-controll\" name=\"algorithmType\" onChange={this.handleChange} value={this.state.algorithmType}>\r\n            <option value=\"random\">random search</option>\r\n            <option value=\"hillClimbing\">neighbourhood search</option>\r\n          </select>\r\n          Algorithm. \r\n          <button className=\"\" onClick={this.handleRestartJobShopWorkerButton}>  Restart with new settings </button>\r\n        </h6>\r\n\r\n        <div style={{marginTop:'10px'}}>\r\n          <h6>Plot of makespan during each different simulation</h6>\r\n          <TwoDPlot data={this.state.makeSpanHistory} width={screenWidth} />\r\n        </div>\r\n        <hr></hr>\r\n        <h6>Schedule with the least makespan</h6>\r\n        <GanttChart schedule={this.state.schedule}/>\r\n        \r\n\r\n        <div className=\"explanation\">\r\n\r\n        <p>\r\nThe Chart above shows the order in which each operation in a water bottling plant must run on each machine to complete all bottling activities in the most efficient manner. \r\nWatch the chart change as the algorithm finds more and more efficient way to run the factory over time. Simulation is slowed down for demonstration purpose.\r\nRun the simulations with different settings below: \r\n</p>\r\n        \r\n          <hr></hr>\r\n          <h3>Explanation</h3>\r\n\r\nIn this demo, we are trying to optimize how to run a water bottling plant. We have 5 machines for different operations, and various different types of products we need to produce.\r\n\r\n\r\n<ol>\r\n  <li>Machine 0 - Bottle Expansion Molding</li>\r\n  <li>Machine 1 - Water Cleaning or purifying Machine </li>\r\n  <li>Machine 2 - Pouring water / Filling Process </li>\r\n  <li>Machine 3 - Capping</li>\r\n  <li>Machine 4 - Labelling</li>\r\n</ol>\r\n\r\nThis factory produces 4 different types of water bottles, and each water bottling operation must be run in the following order:\r\n<ol>\r\n  <li><span style={{backgroundColor:`${jobIdToColour(0)}`}}>Job 0 - Spring Water 16oz </span>\r\n      <ol>\r\n        <li>Bottle Expansion - 10 seconds</li>\r\n        <li>Water Purifying - 30 seconds</li>\r\n        <li>Water Filling - 10 seconds</li>\r\n        <li>Bottle Capping - 10 seconds</li>\r\n        <li>Bottle Labeling - 8 seconds</li>\r\n      </ol>\r\n  </li>\r\n  <li><span style={{backgroundColor:`${jobIdToColour(1)}`}}>Job 1 - Distilled Water 16 oz</span>\r\n      <ol>\r\n        <li>Bottle Expansion - 50 seconds</li>\r\n        <li>Water Purifying - 60 seconds</li>\r\n        <li>Water Filling - 10 seconds</li>\r\n        <li>Bottle Capping - 10 seconds</li>\r\n        <li>Bottle Labeling - 16 seconds</li>\r\n      </ol>\r\n  </li>\r\n  <li><span style={{backgroundColor:`${jobIdToColour(2)}`}}>Job 2 - Distilled Water 32 oz</span>\r\n      <ol>\r\n        <li>Bottle Expansion - 30 seconds</li>\r\n        <li>Water Purifying - 90 seconds</li>\r\n        <li>Water Filling - 20 seconds</li>\r\n        <li>Bottle Capping - 10 seconds</li>\r\n        <li>Bottle Labeling - 16 seconds</li>\r\n      </ol>\r\n  </li>\r\n  <li><span style={{backgroundColor:`${jobIdToColour(3)}`}}>Job 3 - Bottoled Water 32 oz</span>\r\n      <ol>\r\n        <li>Bottle Expansion - 15 seconds</li>\r\n        <li>Water Purifying - 90 seconds</li>\r\n        <li>Water Filling - 20 seconds</li>\r\n        <li>Bottle Capping - 10 seconds</li>\r\n        <li>Bottle Labeling - 10 seconds</li>\r\n      </ol>\r\n  </li>\r\n</ol>\r\n\r\nAlgorithm that runs in the background finds the most optimal way of running all the jobs in the given order. \r\n\r\nThe Chart shows the order in which each job must run on each machine to complete all bottling activities in the most efficient manner. \r\nWatch the chart change as the algorithm finds more and more efficient way to run the factory. \r\n\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","function JSSPProblemInstance(n,m){\r\n    this.numJobs = n;\r\n    this.numMachines = m\r\n    this.jobs = []; // list of lists.\r\n}\r\n\r\nfunction JSSPGanttChartSolution(schedule){\r\n    /**\r\n     * Gantt Chart looks like this:\r\n     * [\r\n     *  [jobId,StartTime,EndTime,jobId,StartTime,EndTime,...]   -> for Machine with Index 0 \r\n     *  [jobId,StartTime,EndTime,...]   -> for Machine with Index 1\r\n     * ]\r\n     * It is useful to have GanttChart in this format because it lets us \r\n     * read the ganttChart in text format without any special help.\r\n     */\r\n    this.schedule = schedule\r\n    this.getMakeSpan = ()=>{\r\n        /**\r\n         * Calculates MakeSpan of an instance of a JSSP Gantt Chart Solution\r\n         * In our definition of ganttChart, we choose last integer of each array if array>0. \r\n         * and return max of them\r\n         */\r\n        const allEnds = this.schedule.map(arrForMachine => {\r\n            if(!arrForMachine.length || arrForMachine.length === 0){\r\n                return 0\r\n            }\r\n            return arrForMachine[arrForMachine.length -1 ]\r\n        });\r\n        return Math.max(...allEnds)\r\n    }\r\n}\r\n\r\n\r\nfunction JSSP1DEncoding(jobs1d){\r\n    /**\r\n     * Most JSSP problems have way too many ways to run, we need to generate options randomly\r\n     * Since randomly generating options is harder in  2d array while meeting all the constraints\r\n     * we will use a 1D Encoding. We also have functions to convert this into Gantt Chart. \r\n     * \r\n     * This can be represented as a singe array as well.\r\n     */\r\n    this.jssp1d = jobs1d\r\n    // Example jssp1d = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n\r\n    this.JSSP1dToGantt = (jobInstance) => {\r\n        /**\r\n         * Given a 1D solution, convert it into Gantt Chart Solution. \r\n         */\r\n        //const test1D = [0,2,1,0,3,1,0,1,2,3,2,1,1,2,3,0,2,0,3,3]\r\n        // const test1D =[0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]\r\n        // const m = 5 // Number of Machines: 0,1,2,3,4,5\r\n        // const n = 4 // Number of Jobs. 0,1,2,3 -> as denoted in the 1d strucutre. \r\n        const ganttChart = []\r\n        for(let i = 0; i<jobInstance.numMachines; i++){\r\n            ganttChart.push([])\r\n        }\r\n        //console.log(ganttChart)\r\n    \r\n        // Next we fill the ganttChart with data based on test1D\r\n        // We need access to the job instance so that we can look at\r\n        \r\n        // Keep Track of last time for each job.\r\n        const lastJobTime = new Array(jobInstance.numJobs).fill(0)\r\n        // console.log(\"Last Job Time\", lastJobTime)\r\n    \r\n        //console.log(jobInstance)\r\n        this.jssp1d.forEach(jobNumber => {\r\n            // job jobNumber is assigned to its respective first. \r\n            const jobDef = jobInstance.jobs[jobNumber]\r\n            // console.log(\"job def is\", jobDef);\r\n            // Get the first one out.\r\n            const firstJob = jobDef.splice(0,2);\r\n            // console.log(`Current Job for Job Number ${jobNumber}  :` ,firstJob)\r\n            const machine = firstJob[0];\r\n            const time = firstJob[1]\r\n    \r\n            // Now fill Gantt Chart\r\n            const firstAvailableTimeOnMachine = ganttChart[machine].length === 0 ? 0 : ganttChart[machine][ganttChart[machine].length -1]\r\n            // What is the last time of dependent job? We can find that out dependent jobs by looking at job instance from before...\r\n            const _lastJobTime = lastJobTime[jobNumber]\r\n            const firstAvailableTime = Math.max(_lastJobTime,firstAvailableTimeOnMachine)\r\n            lastJobTime[jobNumber] = firstAvailableTime+time\r\n            \r\n            const ganttSchedule = [jobNumber,firstAvailableTime+1,firstAvailableTime+time ]\r\n            ganttChart[machine] = [...ganttChart[machine], ...ganttSchedule]\r\n            \r\n        })\r\n    \r\n        //console.log(ganttChart)\r\n\r\n        return new JSSPGanttChartSolution(ganttChart)\r\n    }\r\n}\r\n\r\nfunction FishesYatesShuffle(array) {\r\n    var currentIndex = array.length, temporaryValue, randomIndex;\r\n  \r\n    // While there remain elements to shuffle...\r\n    while (0 !== currentIndex) {\r\n  \r\n      // Pick a remaining element...\r\n      randomIndex = Math.floor(Math.random() * currentIndex);\r\n      currentIndex -= 1;\r\n  \r\n      // And swap it with the current element.\r\n      temporaryValue = array[currentIndex];\r\n      array[currentIndex] = array[randomIndex];\r\n      array[randomIndex] = temporaryValue;\r\n    }\r\n  \r\n    return array;\r\n}\r\n\r\nfunction generateRandom1D(numMachines, numJobs) {\r\n    // We want each jobs repetead numMachines of times. \r\n    let jobs = []\r\n    for(let i = 0;i < numJobs; i++){\r\n        const values = new Array(numMachines).fill(i) // Fill with Job Number \r\n        jobs = [...jobs, ...values]\r\n    }\r\n    const jssp1d = new JSSP1DEncoding(FishesYatesShuffle(jobs))\r\n    return jssp1d\r\n    console.log(jobs)\r\n}\r\n\r\nexport {\r\n    JSSPProblemInstance,\r\n    JSSPGanttChartSolution,\r\n    JSSP1DEncoding,\r\n    FishesYatesShuffle,\r\n    generateRandom1D\r\n}","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}